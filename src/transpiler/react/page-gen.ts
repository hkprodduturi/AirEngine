/**
 * Page component extraction — generates separate *.jsx files for each @page scope.
 */

import type { TranspileContext } from '../context.js';
import type { UIAnalysis } from '../normalize-ui.js';
import type { OutputFile } from '../index.js';
import { resolveBindChain } from '../normalize-ui.js';
import {
  capitalize, ROOT_SCOPE,
  analyzePageDependencies, getHookableStateProps,
} from './helpers.js';
import { generateJSX } from './jsx-gen.js';

// ---- Page Component Generation ----

/**
 * Generate separate page component files for each @page scope.
 * Only runs for fullstack apps with pages.
 */
export function generatePageComponents(
  ctx: TranspileContext,
  analysis: UIAnalysis,
): OutputFile[] {
  if (!ctx.hasBackend || !analysis.hasPages) return [];

  const hookMap = getHookableStateProps(ctx);
  const files: OutputFile[] = [];

  for (const page of analysis.pages) {
    const pageName = capitalize(page.name);
    const deps = analyzePageDependencies(page.children, ctx, analysis);

    // Determine which state props are served by resource hooks
    const hookedProps = new Set<string>();
    const hookImports: { hookName: string; stateVar: string }[] = [];
    for (const s of deps.stateProps) {
      const mapping = hookMap.get(s);
      if (mapping) {
        hookedProps.add(s);
        hookImports.push({ hookName: mapping.hookName, stateVar: s });
      }
    }

    // Build prop names: exclude hook-covered state vars + their setters
    const propNames: string[] = [];
    for (const s of deps.stateProps) {
      if (hookedProps.has(s)) continue; // data comes from hook
      propNames.push(s);
      propNames.push('set' + capitalize(s));
    }
    for (const s of deps.setterProps) {
      if (hookedProps.has(s)) continue;
      const setName = 'set' + capitalize(s);
      if (!propNames.includes(setName)) propNames.push(setName);
    }
    for (const m of deps.mutationProps) {
      const safeName = m.replace(/\./g, '_');
      if (!propNames.includes(safeName)) propNames.push(safeName);
    }
    if (deps.needsNav) {
      if (!propNames.includes('currentPage')) propNames.push('currentPage');
      if (!propNames.includes('setCurrentPage')) propNames.push('setCurrentPage');
    }

    const lines: string[] = [];
    lines.push(`// Generated by AirEngine — ${pageName} page component`);

    // Hook imports
    for (const hi of hookImports) {
      lines.push(`import ${hi.hookName} from '../hooks/${hi.hookName}.js';`);
    }
    lines.push('');

    const propsStr = propNames.length > 0 ? `{ ${propNames.join(', ')} }` : '{}';
    lines.push(`export default function ${pageName}Page(${propsStr}) {`);

    // Hook calls — destructure data as the state var name
    for (const hi of hookImports) {
      lines.push(`  const { data: ${hi.stateVar}, loading: ${hi.stateVar}Loading, error: ${hi.stateVar}Error } = ${hi.hookName}();`);
    }
    if (hookImports.length > 0) lines.push('');

    // Detect form pages
    const isFormPage = page.children.some(c => {
      if (c.kind === 'element' && c.element === 'form') return true;
      if (c.kind === 'binary' && c.operator === '>') {
        const left = c.left;
        if (left.kind === 'element' && left.element === 'form') return true;
        if (left.kind === 'binary' && left.operator === ':') {
          const resolved = resolveBindChain(left);
          if (resolved && resolved.element === 'form') return true;
        }
      }
      return false;
    });

    lines.push('  return (');

    if (isFormPage) {
      lines.push('    <div className="flex items-center justify-center min-h-screen p-4">');
      lines.push('      <div className="w-full max-w-md space-y-6 rounded-[var(--radius)] border border-[var(--border)] bg-[var(--surface)] p-8">');
      lines.push(`        <h2 className="text-2xl font-bold text-center">${capitalize(page.name)}</h2>`);
      const childJsx = page.children.map(c =>
        generateJSX(c, ctx, analysis, ROOT_SCOPE, 8)
      ).filter(Boolean).join('\n');
      lines.push(childJsx);
      lines.push('      </div>');
      lines.push('    </div>');
    } else {
      lines.push('    <div>');
      const childJsx = page.children.map(c =>
        generateJSX(c, ctx, analysis, ROOT_SCOPE, 6)
      ).filter(Boolean).join('\n');
      lines.push(childJsx);
      lines.push('    </div>');
    }

    lines.push('  );');
    lines.push('}');
    lines.push('');

    files.push({
      path: `src/pages/${pageName}Page.jsx`,
      content: lines.join('\n'),
    });
  }

  return files;
}
