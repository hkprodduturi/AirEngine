/**
 * React code generator — thin orchestrator shell.
 *
 * Re-exports generateApp, generateLayout, generatePageComponents.
 */

import type { TranspileContext } from '../context.js';
import type { UIAnalysis } from '../normalize-ui.js';
import { detectPatterns } from '../component-gen.js';
import { capitalize, indent, hasAuthRoutes, isAuthPageName, AUTH_MUTATION_NAMES } from './helpers.js';
import { generateStateDecls } from './state-gen.js';
import { generatePersistLoad, generatePersistSave } from './persist-gen.js';
import { generateMutations } from './mutation-gen.js';
import { getPostLoginPage } from './mutation-gen.js';
import { generateHookEffects } from './hook-gen.js';
import { generateRootJSX } from './jsx-gen.js';

// Re-exports
export { generateLayout } from './layout-gen.js';
export { generatePageComponents } from './page-gen.js';

// ---- Main entry ----

export function generateApp(ctx: TranspileContext, analysis: UIAnalysis): string {
  const lines: string[] = [];

  const hasAuthMutations = hasAuthRoutes(ctx);
  const hasLoginPage = analysis.pages.some(p => isAuthPageName(p.name));
  const hasAuthGating = hasAuthMutations && ctx.hasBackend && analysis.hasPages && hasLoginPage;

  const useLazy = ctx.hasBackend && analysis.hasPages && analysis.pages.length >= 3;
  if (useLazy) {
    lines.push("import { useState, useEffect, lazy, Suspense } from 'react';");
  } else {
    lines.push("import { useState, useEffect } from 'react';");
  }
  if (ctx.hasBackend && ctx.apiRoutes.length > 0) {
    lines.push("import * as api from './api.js';");
  }
  // Import page components for fullstack apps with pages
  if (ctx.hasBackend && analysis.hasPages) {
    if (useLazy) {
      for (const page of analysis.pages) {
        const pageName = capitalize(page.name);
        lines.push(`const ${pageName}Page = lazy(() => import('./pages/${pageName}Page.jsx'));`);
      }
    } else {
      for (const page of analysis.pages) {
        const pageName = capitalize(page.name);
        lines.push(`import ${pageName}Page from './pages/${pageName}Page.jsx';`);
      }
    }
  }
  // Import reusable components when patterns detected (skip when auth-gated — pages import their own)
  if (ctx.hasBackend && !hasAuthGating) {
    const flags = detectPatterns(ctx.uiNodes);
    if (flags.hasTable) lines.push("import DataTable from './components/DataTable.jsx';");
    if (flags.hasIteration) lines.push("import EmptyState from './components/EmptyState.jsx';");
    if (flags.hasStat) lines.push("import StatCard from './components/StatCard.jsx';");
  }
  lines.push('');
  lines.push(`// Generated by AirEngine from ${ctx.appName}.air`);
  lines.push('export default function App() {');

  if (hasAuthGating) {
    // ---- Slim App: only auth state ----
    const postLoginPage = getPostLoginPage(analysis);
    lines.push('  const [user, setUser] = useState(null);');
    lines.push('  const [authError, setAuthError] = useState(null);');
    lines.push(`  const [currentPage, setCurrentPage] = useState('login');`);
    // Include loading/error state if declared (used by auth mutations)
    const hasLoading = ctx.state.some(f => f.name === 'loading');
    const hasError = ctx.state.some(f => f.name === 'error');
    if (hasLoading) lines.push('  const [loading, setLoading] = useState(false);');
    if (hasError) lines.push('  const [error, setError] = useState(null);');
    lines.push('');

    // Restore BOTH token AND user from localStorage
    lines.push('  // Restore auth session from localStorage on mount');
    lines.push('  useEffect(() => {');
    lines.push("    const savedToken = localStorage.getItem('auth_token');");
    lines.push(`    const savedUser = localStorage.getItem('${ctx.appName}_user');`);
    lines.push('    if (savedToken) api.setToken(savedToken);');
    lines.push('    if (savedUser) {');
    lines.push('      try {');
    lines.push('        setUser(JSON.parse(savedUser));');
    lines.push(`        setCurrentPage('${postLoginPage}');`);
    lines.push('      } catch (_) {}');
    lines.push('    }');
    lines.push('  }, []);');
    lines.push('');

    // Only auth mutations (login + register — not logout, we generate that explicitly)
    const authOnlyMutations = analysis.mutations.filter(m =>
      AUTH_MUTATION_NAMES.has(m.name) && m.name !== 'logout'
    );
    if (authOnlyMutations.length > 0) {
      const authAnalysis = { ...analysis, mutations: authOnlyMutations };
      const mutCode = generateMutations(ctx, authAnalysis);
      if (mutCode.length) {
        lines.push(...indent(mutCode, 2));
        lines.push('');
      }
    }

    // Always generate logout when auth-gated (Layout and pages need it)
    lines.push('  const logout = () => {');
    if (ctx.hasBackend && ctx.apiRoutes.length > 0) {
      lines.push('    api.clearToken();');
    }
    lines.push('    setUser(null);');
    lines.push(`    localStorage.removeItem('${ctx.appName}_user');`);
    lines.push(`    localStorage.removeItem('auth_token');`);
    lines.push("    setCurrentPage('login');");
    lines.push('  };');
    lines.push('');

    // Persist: load on mount (auth-related persistence like cookie tokens)
    const loadCode = generatePersistLoad(ctx);
    if (loadCode.length) {
      lines.push(...indent(loadCode, 2));
      lines.push('');
    }

    // Persist: save on change
    const saveCode = generatePersistSave(ctx);
    if (saveCode.length) {
      lines.push(...indent(saveCode, 2));
      lines.push('');
    }

    // isAuthed gate
    lines.push('  const isAuthed = !!user;');
    lines.push('');

    // Skip: data-fetching hooks, component imports (pages handle all that)

  } else {
    // ---- Original full App behavior ----

    // State declarations
    lines.push(...indent(generateStateDecls(ctx), 2));
    lines.push('');

    // Auth error state for login/register feedback
    if (hasAuthMutations) {
      lines.push('  const [authError, setAuthError] = useState(null);');
      lines.push('');
    }

    // Page navigation state (if pages exist)
    if (analysis.hasPages) {
      const defaultPage = analysis.pages[0]?.name ?? 'home';
      lines.push(`  const [currentPage, setCurrentPage] = useState('${defaultPage}');`);
      lines.push('');
    }

    // Restore auth token on mount
    if (hasAuthMutations && ctx.hasBackend && ctx.apiRoutes.length > 0) {
      lines.push('  // Restore auth token from localStorage on mount');
      lines.push('  useEffect(() => {');
      lines.push("    const saved = localStorage.getItem('auth_token');");
      lines.push('    if (saved) api.setToken(saved);');
      lines.push('  }, []);');
      lines.push('');
    }

    // Persist: load on mount
    const loadCode = generatePersistLoad(ctx);
    if (loadCode.length) {
      lines.push(...indent(loadCode, 2));
      lines.push('');
    }

    // Persist: save on change
    const saveCode = generatePersistSave(ctx);
    if (saveCode.length) {
      lines.push(...indent(saveCode, 2));
      lines.push('');
    }

    // Mutation functions
    const mutCode = generateMutations(ctx, analysis);
    if (mutCode.length) {
      lines.push(...indent(mutCode, 2));
      lines.push('');
    }

    // Hook effects
    const hookCode = generateHookEffects(ctx);
    if (hookCode.length) {
      lines.push(...indent(hookCode, 2));
      lines.push('');
    }
  }

  // JSX return
  lines.push('  return (');
  lines.push(...indent(generateRootJSX(ctx, analysis, useLazy, hasAuthGating), 4));
  lines.push('  );');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}
