/**
 * README Generator
 *
 * Generates a README.md for the fullstack project with setup instructions,
 * API route tables, database model documentation, environment variables,
 * and deployment instructions.
 */

import type { TranspileContext } from '../context.js';
import type { AirType } from '../../parser/types.js';

export function generateReadme(ctx: TranspileContext): string {
  const lines: string[] = [];

  lines.push(`# ${capitalize(ctx.appName)}`);
  lines.push('');
  lines.push(`Full-stack application generated by AirEngine from \`${ctx.appName}.air\`.`);
  lines.push('');

  // Tech stack
  lines.push('## Tech Stack');
  lines.push('');
  lines.push('| Layer | Technology |');
  lines.push('|-------|-----------|');
  lines.push('| Frontend | React + Tailwind CSS + Vite |');
  lines.push('| Backend | Express.js + TypeScript |');
  if (ctx.db) {
    lines.push('| Database | SQLite + Prisma ORM |');
  }
  if (ctx.auth) {
    lines.push('| Auth | JWT (HMAC-SHA256) |');
  }
  lines.push('');

  // Setup
  lines.push('## Quick Start');
  lines.push('');
  lines.push('### Prerequisites');
  lines.push('');
  lines.push('- Node.js 18+ and npm');
  lines.push('');
  lines.push('### Client');
  lines.push('```bash');
  lines.push('cd client');
  lines.push('npm install');
  lines.push('npm run dev');
  lines.push('```');
  lines.push('');
  lines.push('### Server');
  lines.push('```bash');
  lines.push('cd server');
  lines.push('npm install');
  if (ctx.db) {
    lines.push('npx prisma db push    # Create database tables');
    lines.push('npx tsx seed.ts       # Seed sample data');
  }
  lines.push('npm run dev');
  lines.push('```');
  lines.push('');
  lines.push('The client runs on `http://localhost:5173` and the server on `http://localhost:3001`.');
  lines.push('');

  // Environment variables
  lines.push('## Environment Variables');
  lines.push('');
  lines.push('Copy `server/.env` and configure for your environment:');
  lines.push('');
  lines.push('| Variable | Required | Default | Description |');
  lines.push('|----------|----------|---------|-------------|');
  lines.push('| `PORT` | No | 3001 | Server port |');
  if (ctx.db) {
    lines.push('| `DATABASE_URL` | Yes | `file:./dev.db` | Database connection URL |');
  }
  if (ctx.auth) {
    lines.push('| `JWT_SECRET` | Yes | dev-secret | Secret for signing JWT tokens |');
  }
  lines.push('| `CORS_ORIGIN` | No | (reflect) | Allowed CORS origin |');
  lines.push('| `NODE_ENV` | No | development | Environment mode |');
  if (ctx.env) {
    for (const v of ctx.env.vars) {
      if (['PORT', 'DATABASE_URL', 'JWT_SECRET', 'CORS_ORIGIN', 'NODE_ENV'].includes(v.name)) continue;
      const req = v.required ? 'Yes' : 'No';
      const def = v.default !== undefined ? String(v.default) : '-';
      lines.push(`| \`${v.name}\` | ${req} | ${def} | - |`);
    }
  }
  lines.push('');

  // API routes table
  if (ctx.apiRoutes.length > 0) {
    const routes = ctx.expandedRoutes;
    lines.push('## API Endpoints');
    lines.push('');
    lines.push('Base URL: `http://localhost:3001/api`');
    lines.push('');

    // Health check
    lines.push('### Health Check');
    lines.push('');
    lines.push('```');
    lines.push('GET /api/health');
    lines.push('```');
    lines.push('');
    lines.push('Returns `{ "status": "ok", "timestamp": "...", "db": "connected" }`');
    lines.push('');

    // Auth endpoints
    if (ctx.auth) {
      const authRoutes = routes.filter(r => r.path.includes('/auth/'));
      if (authRoutes.length > 0) {
        lines.push('### Authentication');
        lines.push('');
        lines.push('These endpoints do not require a Bearer token.');
        lines.push('');
        lines.push('| Method | Path | Description |');
        lines.push('|--------|------|-------------|');
        for (const route of authRoutes) {
          const desc = route.path.endsWith('/login') ? 'Login with email/password' :
            route.path.endsWith('/register') ? 'Register a new account' : route.handler;
          lines.push(`| \`${route.method}\` | \`${route.path}\` | ${desc} |`);
        }
        lines.push('');
        lines.push('**Login Request:**');
        lines.push('```json');
        lines.push('{ "email": "user@example.com", "password": "secret" }');
        lines.push('```');
        lines.push('');
        lines.push('**Response:**');
        lines.push('```json');
        lines.push('{ "user": { "id": 1, "email": "user@example.com", "role": "admin" }, "token": "eyJ..." }');
        lines.push('```');
        lines.push('');
        lines.push('Include the token in subsequent requests:');
        lines.push('```');
        lines.push('Authorization: Bearer <token>');
        lines.push('```');
        lines.push('');
      }
    }

    // Resource endpoints
    const nonAuthRoutes = routes.filter(r => !r.path.includes('/auth/'));
    if (nonAuthRoutes.length > 0) {
      lines.push('### Resources');
      lines.push('');
      if (ctx.auth) {
        lines.push('All resource endpoints require a valid Bearer token.');
        lines.push('');
      }
      lines.push('| Method | Path | Description |');
      lines.push('|--------|------|-------------|');
      for (const route of nonAuthRoutes) {
        const desc = describeRoute(route.method, route.path, route.handler);
        lines.push(`| \`${route.method}\` | \`${route.path}\` | ${desc} |`);
      }
      lines.push('');

      // Response format
      lines.push('**List endpoints** return paginated data:');
      lines.push('```json');
      lines.push('{ "data": [...], "meta": { "page": 1, "limit": 20, "total": 42, "totalPages": 3 } }');
      lines.push('```');
      lines.push('');
      lines.push('**Query parameters for list endpoints:**');
      lines.push('- `page` — Page number (default: 1)');
      lines.push('- `limit` — Items per page (default: 20, max: 100)');
      lines.push('- `search` — Text search across string fields');
      lines.push('- `sort` — Sort field and direction, e.g., `sort=created_at:desc`');
      lines.push('');
      lines.push('**Error responses:**');
      lines.push('```json');
      lines.push('{ "error": "Not found" }');
      lines.push('{ "error": "Validation error", "details": "Missing required fields: name" }');
      lines.push('```');
      lines.push('');
      lines.push('**Status codes:** 200 OK, 201 Created, 204 No Content (delete), 400 Bad Request, 401 Unauthorized, 404 Not Found, 409 Conflict, 429 Rate Limited, 500 Server Error');
      lines.push('');
    }
  }

  // Database models table
  if (ctx.db) {
    lines.push('## Database Models');
    lines.push('');
    for (const model of ctx.db.models) {
      lines.push(`### ${model.name}`);
      lines.push('');
      lines.push('| Field | Type | Constraints |');
      lines.push('|-------|------|-------------|');
      for (const field of model.fields) {
        const constraints: string[] = [];
        if (field.primary) constraints.push('primary');
        if (field.required) constraints.push('required');
        if (field.auto) constraints.push('auto');
        if (field.default !== undefined) constraints.push(`default: ${field.default}`);
        lines.push(`| ${field.name} | ${describeType(field.type)} | ${constraints.join(', ') || '-'} |`);
      }
      lines.push('');
    }
  }

  // Available scripts
  lines.push('## Available Scripts');
  lines.push('');
  lines.push('### Client');
  lines.push('| Command | Description |');
  lines.push('|---------|-------------|');
  lines.push('| `npm run dev` | Start dev server with HMR |');
  lines.push('| `npm run build` | Build for production |');
  lines.push('| `npm run preview` | Preview production build |');
  lines.push('');
  lines.push('### Server');
  lines.push('| Command | Description |');
  lines.push('|---------|-------------|');
  lines.push('| `npm run dev` | Start dev server with auto-reload |');
  lines.push('| `npm run build` | Compile TypeScript |');
  lines.push('| `npm start` | Run production build |');
  if (ctx.db) {
    lines.push('| `npm run db:push` | Push schema to database |');
    lines.push('| `npm run db:seed` | Seed sample data |');
    lines.push('| `npm run db:studio` | Open Prisma Studio |');
  }
  lines.push('');

  // Deployment section (only if @deploy exists)
  if (ctx.deploy) {
    const target = String(ctx.deploy.properties.target ?? 'docker');
    const port = resolvePort(ctx);

    if (target === 'docker') {
      lines.push('## Deployment');
      lines.push('');
      lines.push('### Docker Compose');
      lines.push('```bash');
      lines.push('cp server/.env.example server/.env');
      lines.push('# Edit server/.env with production values');
      lines.push('docker compose up --build -d');
      lines.push('```');
      lines.push('');
      if (ctx.db) {
        lines.push('### Database Initialization (before first deploy)');
        lines.push('```bash');
        lines.push('cd server');
        lines.push('mkdir -p data');
        lines.push('DATABASE_URL="file:../data/app.db" npx prisma db push');
        lines.push('DATABASE_URL="file:../data/app.db" npx tsx seed.ts  # optional');
        lines.push('```');
        lines.push('');
        lines.push('> These commands write to `server/data/app.db` on the host, which Docker Compose bind-mounts into the container at `/app/data/app.db`.');
        lines.push('');
      }
      lines.push('### Manual Docker Build');
      lines.push('```bash');
      lines.push('cd server');
      lines.push(`docker build -t ${ctx.appName}-server .`);
      lines.push(`docker run -p ${port}:${port} --env-file .env ${ctx.appName}-server`);
      lines.push('```');
      lines.push('');
    } else {
      lines.push('## Deployment');
      lines.push('');
      lines.push(`> TODO: Deploy target \`${target}\` is not yet supported by AirEngine. Only \`docker\` is currently implemented.`);
      lines.push('');
    }
  }

  lines.push('---');
  lines.push('');
  lines.push('Generated by [AirEngine](https://github.com/AirEngine/AirEngine)');
  lines.push('');

  return lines.join('\n');
}

export function describeType(type: AirType): string {
  switch (type.kind) {
    case 'optional': return `${describeType((type as { kind: 'optional'; of: AirType }).of)}?`;
    case 'enum': return `enum(${(type as { kind: 'enum'; values: string[] }).values.join(', ')})`;
    case 'array': return `${describeType((type as { kind: 'array'; of: AirType }).of)}[]`;
    default: return type.kind;
  }
}

/** Generate a human-readable description for a route */
function describeRoute(method: string, path: string, handler: string): string {
  const modelMatch = handler.match(/^~db\.(\w+)\.(\w+)$/);
  if (modelMatch) {
    const [, model, operation] = modelMatch;
    switch (operation) {
      case 'findMany': return `List all ${model}s`;
      case 'findUnique': return `Get a ${model} by ID`;
      case 'findFirst': return `Get a ${model} by ID`;
      case 'create': return `Create a new ${model}`;
      case 'update': return `Update a ${model}`;
      case 'delete': return `Delete a ${model}`;
      case 'aggregate': return `Get ${model} statistics`;
    }
  }
  return `\`${handler}\``;
}

function resolvePort(ctx: TranspileContext): string {
  if (ctx.deploy?.properties.port !== undefined) {
    return String(ctx.deploy.properties.port);
  }
  if (ctx.env) {
    const portVar = ctx.env.vars.find(v => v.name === 'PORT');
    if (portVar?.default !== undefined) return String(portVar.default);
  }
  return '3001';
}

function capitalize(s: string): string {
  if (!s) return s;
  return s.charAt(0).toUpperCase() + s.slice(1);
}
