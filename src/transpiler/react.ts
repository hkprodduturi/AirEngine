/**
 * Core React Code Generator
 *
 * Walks the TranspileContext + UIAnalysis and emits a complete App.jsx
 * with useState, useEffect, mutation functions, and JSX.
 */

import type { AirUINode, AirField, AirType } from '../parser/types.js';
import type { TranspileContext } from './context.js';
import type { UIAnalysis, ResolvedBind } from './normalize-ui.js';
import { resolveBindChain } from './normalize-ui.js';
import { mapElement } from './element-map.js';
import { expandCrud, routeToFunctionName } from './route-utils.js';

// ---- Icon emoji map ----

const ICON_EMOJI: Record<string, string> = {
  zap: '&#9889;', shield: '&#128737;', users: '&#128101;',
  star: '&#11088;', heart: '&#10084;', check: '&#10004;',
  x: '&#10006;', search: '&#128269;', settings: '&#9881;',
  mail: '&#9993;', lock: '&#128274;', globe: '&#127760;',
  home: '&#127968;', bell: '&#128276;', edit: '&#9998;',
  trash: '&#128465;', plus: '&#43;', minus: '&#8722;',
  arrow: '&#10140;', clock: '&#128339;', calendar: '&#128197;',
};

// ---- Scope tracking for code generation ----

interface Scope {
  iterVar?: string;
  iterData?: string;
  baseArray?: string;
  insideIter: boolean;
  insideForm?: boolean;
}

const ROOT_SCOPE: Scope = { insideIter: false };

// ---- Main entry ----

export function generateApp(ctx: TranspileContext, analysis: UIAnalysis): string {
  const lines: string[] = [];

  lines.push("import { useState, useEffect } from 'react';");
  if (ctx.hasBackend && ctx.apiRoutes.length > 0) {
    lines.push("import * as api from './api.js';");
  }
  lines.push('');
  lines.push(`// Generated by AirEngine from ${ctx.appName}.air`);
  lines.push('export default function App() {');

  // State declarations
  lines.push(...indent(generateStateDecls(ctx), 2));
  lines.push('');

  // Page navigation state (if pages exist)
  if (analysis.hasPages) {
    const defaultPage = analysis.pages[0]?.name ?? 'home';
    lines.push(`  const [currentPage, setCurrentPage] = useState('${defaultPage}');`);
    lines.push('');
  }

  // Persist: load on mount
  const loadCode = generatePersistLoad(ctx);
  if (loadCode.length) {
    lines.push(...indent(loadCode, 2));
    lines.push('');
  }

  // Persist: save on change
  const saveCode = generatePersistSave(ctx);
  if (saveCode.length) {
    lines.push(...indent(saveCode, 2));
    lines.push('');
  }

  // Mutation functions
  const mutCode = generateMutations(ctx, analysis);
  if (mutCode.length) {
    lines.push(...indent(mutCode, 2));
    lines.push('');
  }

  // Hook effects
  const hookCode = generateHookEffects(ctx);
  if (hookCode.length) {
    lines.push(...indent(hookCode, 2));
    lines.push('');
  }

  // JSX return
  lines.push('  return (');
  lines.push(...indent(generateRootJSX(ctx, analysis), 4));
  lines.push('  );');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

// ---- State Declarations ----

function generateStateDecls(ctx: TranspileContext): string[] {
  const lines: string[] = [];
  for (const field of ctx.state) {
    const defVal = defaultForType(field.type);
    const setter = 'set' + capitalize(field.name);
    lines.push(`const [${field.name}, ${setter}] = useState(${defVal});`);
  }
  return lines;
}

function defaultForType(type: AirType): string {
  switch (type.kind) {
    case 'str':
      return type.default !== undefined ? JSON.stringify(type.default) : "''";
    case 'int':
      return type.default !== undefined ? String(type.default) : '0';
    case 'float':
      return type.default !== undefined ? String(type.default) : '0';
    case 'bool':
      return type.default !== undefined ? String(type.default) : 'false';
    case 'date':
    case 'datetime':
      return "''";
    case 'enum':
      return type.default !== undefined
        ? JSON.stringify(type.default)
        : JSON.stringify(type.values[0] ?? '');
    case 'array':
      return '[]';
    case 'object':
      return generateObjectDefault(type.fields);
    case 'optional':
      return 'null';
    case 'ref':
      return 'null';
  }
}

function generateObjectDefault(fields: AirField[]): string {
  const entries = fields.map(f => `${f.name}: ${defaultForType(f.type)}`);
  return `{ ${entries.join(', ')} }`;
}

// ---- Persist: Key Resolution ----

/**
 * Resolves a persist key like "user.token" into:
 * - storeKey: the cookie/storage key name ("auth-user-token")
 * - getter: JS expression to read the value ("user?.token")
 * - depVar: the root state variable for useEffect dependency ("user")
 * - loadSetter: function that returns a setter statement for loading
 *
 * Simple keys like "items" resolve to themselves.
 * Dot-path keys like "user.token" access a sub-property of state.
 */
function resolvePersistKey(key: string, ctx: TranspileContext): {
  storeKey: string;
  getter: string;
  depVar: string;
  loadSetter: (valueExpr: string) => string;
} {
  const parts = key.split('.');
  const rootVar = parts[0];
  const storeKey = `${ctx.appName}-${key.replace(/\./g, '-')}`;

  if (parts.length === 1) {
    // Simple key: "items" → getter=items, setter=setItems(val)
    return {
      storeKey,
      getter: rootVar,
      depVar: rootVar,
      loadSetter: (val) => `set${capitalize(rootVar)}(${val})`,
    };
  }

  // Dot-path key: "user.token" → getter=user?.token, setter=setUser(prev => ({...prev, token: val}))
  const subPath = parts.slice(1).join('.');
  const optionalChain = parts.slice(1).reduce((acc, p) => `${acc}?.${p}`, rootVar);

  return {
    storeKey,
    getter: optionalChain,
    depVar: rootVar,
    loadSetter: (val) => {
      // Build nested spread: setUser(prev => ({...prev, token: val}))
      const lastProp = parts[parts.length - 1];
      return `set${capitalize(rootVar)}(prev => ({ ...prev, ${lastProp}: ${val} }))`;
    },
  };
}

// ---- Persist: Load ----

function generatePersistLoad(ctx: TranspileContext): string[] {
  if (ctx.persistKeys.length === 0) return [];

  const lines: string[] = [];

  if (ctx.persistMethod === 'localStorage' || ctx.persistMethod === 'session') {
    const storage = ctx.persistMethod === 'session' ? 'sessionStorage' : 'localStorage';
    lines.push('useEffect(() => {');
    lines.push('  try {');
    for (let i = 0; i < ctx.persistKeys.length; i++) {
      const key = ctx.persistKeys[i];
      const { storeKey, getter, loadSetter } = resolvePersistKey(key, ctx);
      const varName = `_saved_${key.replace(/\./g, '_')}`;
      const rawVar = ctx.persistKeys.length > 1 ? `raw${i}` : 'raw';
      lines.push(`    const ${rawVar} = ${storage}.getItem('${storeKey}');`);
      lines.push(`    if (${rawVar}) { const ${varName} = JSON.parse(${rawVar}); ${loadSetter(varName)}; }`);
    }
    lines.push('  } catch (e) { /* ignore corrupt storage */ }');
    lines.push('}, []);');
  } else if (ctx.persistMethod === 'cookie') {
    // Cookie persistence — warning for httpOnly
    if (ctx.persistOptions.httpOnly) {
      lines.push('// WARNING: httpOnly cookies require server-side handling');
    }
    lines.push('useEffect(() => {');
    lines.push('  try {');
    lines.push('    const cookies = Object.fromEntries(document.cookie.split("; ").map(c => c.split("=")));');
    for (const key of ctx.persistKeys) {
      const { storeKey, getter, loadSetter } = resolvePersistKey(key, ctx);
      const varName = `_saved_${key.replace(/\./g, '_')}`;
      lines.push(`    if (cookies['${storeKey}']) { const ${varName} = JSON.parse(decodeURIComponent(cookies['${storeKey}'])); ${loadSetter(varName)}; }`);
    }
    lines.push('  } catch (e) { /* ignore */ }');
    lines.push('}, []);');
  }

  return lines;
}

// ---- Persist: Save ----

function generatePersistSave(ctx: TranspileContext): string[] {
  if (ctx.persistKeys.length === 0) return [];

  const lines: string[] = [];

  if (ctx.persistMethod === 'localStorage' || ctx.persistMethod === 'session') {
    const storage = ctx.persistMethod === 'session' ? 'sessionStorage' : 'localStorage';
    for (const key of ctx.persistKeys) {
      const { storeKey, getter, depVar } = resolvePersistKey(key, ctx);
      const isDotPath = key.includes('.');
      lines.push(`useEffect(() => {`);
      if (isDotPath) {
        lines.push(`  if (${getter} !== undefined) ${storage}.setItem('${storeKey}', JSON.stringify(${getter}));`);
      } else {
        lines.push(`  ${storage}.setItem('${storeKey}', JSON.stringify(${getter}));`);
      }
      lines.push(`}, [${depVar}]);`);
    }
  } else if (ctx.persistMethod === 'cookie') {
    const maxAge = ctx.persistOptions['7d'] ? '; max-age=604800' : '';
    for (const key of ctx.persistKeys) {
      const { storeKey, getter, depVar } = resolvePersistKey(key, ctx);
      const isDotPath = key.includes('.');
      lines.push(`useEffect(() => {`);
      if (isDotPath) {
        lines.push(`  if (${getter} !== undefined) document.cookie = '${storeKey}=' + encodeURIComponent(JSON.stringify(${getter})) + '; path=/${maxAge}';`);
      } else {
        lines.push(`  document.cookie = '${storeKey}=' + encodeURIComponent(JSON.stringify(${getter})) + '; path=/${maxAge}';`);
      }
      lines.push(`}, [${depVar}]);`);
    }
  }

  return lines;
}

// ---- Mutation Functions ----

function generateMutations(ctx: TranspileContext, analysis: UIAnalysis): string[] {
  const lines: string[] = [];
  const arrayField = ctx.state.find(f => f.type.kind === 'array');
  const arrayName = arrayField?.name;

  const canWireApi = ctx.hasBackend && ctx.apiRoutes.length > 0;
  const expandedRoutes = canWireApi ? expandCrud(ctx.apiRoutes) : [];

  for (const mut of analysis.mutations) {
    const name = mut.name;
    const match = canWireApi ? findMatchingRoute(name, expandedRoutes, ctx) : null;

    if (name === 'add' || name === 'addItem') {
      if (match) {
        lines.push(`const ${name} = async (data) => {`);
        lines.push(`  try {`);
        lines.push(`    await api.${match.fnName}(data);`);
        if (match.refetchFnName && match.refetchSetter) {
          lines.push(`    const updated = await api.${match.refetchFnName}();`);
          lines.push(`    ${match.refetchSetter}(updated);`);
        }
        lines.push(`  } catch (err) {`);
        lines.push(`    console.error('${name} failed:', err);`);
        lines.push(`  }`);
        lines.push('};');
      } else if (arrayName) {
        lines.push(`const ${name} = (data) => {`);
        lines.push(`  ${setter(arrayName)}(prev => [...prev, { ...data, id: Date.now() }]);`);
        lines.push('};');
      }
    } else if (name === 'del' || name === 'delItem' || name === 'remove') {
      if (match) {
        lines.push(`const ${name} = async (id) => {`);
        lines.push(`  try {`);
        lines.push(`    await api.${match.fnName}(id);`);
        if (match.refetchFnName && match.refetchSetter) {
          lines.push(`    const updated = await api.${match.refetchFnName}();`);
          lines.push(`    ${match.refetchSetter}(updated);`);
        }
        lines.push(`  } catch (err) {`);
        lines.push(`    console.error('${name} failed:', err);`);
        lines.push(`  }`);
        lines.push('};');
      } else if (arrayName) {
        lines.push(`const ${name} = (id) => {`);
        lines.push(`  ${setter(arrayName)}(prev => prev.filter(item => item.id !== id));`);
        lines.push('};');
      }
    } else if (name === 'toggle') {
      if (match) {
        lines.push(`const ${name} = async (id, field) => {`);
        lines.push(`  try {`);
        if (arrayName) {
          lines.push(`    const current = ${arrayName}.find(i => i.id === id);`);
          lines.push(`    await api.${match.fnName}(id, { [field]: !(current?.[field]) });`);
        } else {
          lines.push(`    await api.${match.fnName}(id, { [field]: true });`);
        }
        if (match.refetchFnName && match.refetchSetter) {
          lines.push(`    const updated = await api.${match.refetchFnName}();`);
          lines.push(`    ${match.refetchSetter}(updated);`);
        }
        lines.push(`  } catch (err) {`);
        lines.push(`    console.error('toggle failed:', err);`);
        lines.push(`  }`);
        lines.push('};');
      } else if (arrayName) {
        lines.push(`const ${name} = (id, field) => {`);
        lines.push(`  ${setter(arrayName)}(prev => prev.map(item => item.id === id ? { ...item, [field]: !item[field] } : item));`);
        lines.push('};');
      }
    } else if (name === 'login') {
      if (match) {
        lines.push(`const login = async (e) => {`);
        lines.push(`  e?.preventDefault?.();`);
        lines.push(`  setLoading(true);`);
        lines.push(`  setError(null);`);
        lines.push(`  try {`);
        lines.push(`    const formData = e?.target ? Object.fromEntries(new FormData(e.target)) : {};`);
        lines.push(`    const result = await api.${match.fnName}(formData);`);
        lines.push(`    setUser(result);`);
        lines.push(`    setCurrentPage('dashboard');`);
        lines.push(`  } catch (err) {`);
        lines.push(`    setError(err.message || 'Login failed');`);
        lines.push(`  } finally {`);
        lines.push(`    setLoading(false);`);
        lines.push(`  }`);
        lines.push('};');
      } else {
        lines.push(`const login = async (e) => {`);
        lines.push(`  e?.preventDefault?.();`);
        lines.push(`  setLoading(true);`);
        lines.push(`  setError(null);`);
        lines.push(`  try {`);
        lines.push(`    // TODO: Replace with actual API call`);
        lines.push(`    console.log('Login attempted');`);
        lines.push(`    setUser({ name: 'User', email: 'user@example.com', token: 'mock-token' });`);
        lines.push(`    setCurrentPage('dashboard');`);
        lines.push(`  } catch (err) {`);
        lines.push(`    setError(err.message || 'Login failed');`);
        lines.push(`  } finally {`);
        lines.push(`    setLoading(false);`);
        lines.push(`  }`);
        lines.push('};');
      }
    } else if (name === 'logout') {
      if (match) {
        lines.push(`const logout = async () => {`);
        lines.push(`  try { await api.${match.fnName}(); } catch (_) {}`);
        lines.push(`  setUser(null);`);
        lines.push(`  setCurrentPage('login');`);
        lines.push('};');
      } else {
        lines.push(`const logout = () => {`);
        lines.push(`  setUser(null);`);
        lines.push(`  setCurrentPage('login');`);
        lines.push('};');
      }
    } else if (name === 'signup' || name === 'register') {
      if (match) {
        lines.push(`const ${name} = async (e) => {`);
        lines.push(`  e?.preventDefault?.();`);
        lines.push(`  setLoading(true);`);
        lines.push(`  setError(null);`);
        lines.push(`  try {`);
        lines.push(`    const formData = e?.target ? Object.fromEntries(new FormData(e.target)) : {};`);
        lines.push(`    await api.${match.fnName}(formData);`);
        lines.push(`    setCurrentPage('login');`);
        lines.push(`  } catch (err) {`);
        lines.push(`    setError(err.message || '${capitalize(name)} failed');`);
        lines.push(`  } finally {`);
        lines.push(`    setLoading(false);`);
        lines.push(`  }`);
        lines.push('};');
      } else {
        lines.push(`const ${name} = async (e) => {`);
        lines.push(`  e?.preventDefault?.();`);
        lines.push(`  setLoading(true);`);
        lines.push(`  setError(null);`);
        lines.push(`  try {`);
        lines.push(`    console.log('${capitalize(name)} attempted');`);
        lines.push(`    setCurrentPage('login');`);
        lines.push(`  } catch (err) {`);
        lines.push(`    setError(err.message || '${capitalize(name)} failed');`);
        lines.push(`  } finally {`);
        lines.push(`    setLoading(false);`);
        lines.push(`  }`);
        lines.push('};');
      }
    } else {
      // Generic mutation stub
      lines.push(`const ${name.replace(/\./g, '_')} = (...args) => {`);
      lines.push(`  console.log('${name}', ...args);`);
      lines.push('};');
    }
    lines.push('');
  }

  return lines;
}

// ---- Hook Effects ----

function generateHookEffects(ctx: TranspileContext): string[] {
  if (ctx.hooks.length === 0) return [];

  const canWireApi = ctx.hasBackend && ctx.apiRoutes.length > 0;
  // Pre-expand routes for matching
  const expandedRoutes = canWireApi ? expandCrud(ctx.apiRoutes) : [];

  const lines: string[] = [];
  for (const hook of ctx.hooks) {
    if (hook.trigger === 'onMount') {
      lines.push('useEffect(() => {');
      for (const action of hook.actions) {
        const apiCall = canWireApi ? matchHookToApiCall(action, expandedRoutes, ctx) : null;
        if (apiCall) {
          lines.push(`  ${apiCall}`);
        } else {
          lines.push(`  console.log('${action}'); // TODO: ${action}`);
        }
      }
      lines.push('}, []);');
    } else if (hook.trigger.startsWith('onChange:')) {
      const dep = hook.trigger.split(':')[1];
      lines.push(`useEffect(() => {`);
      for (const action of hook.actions) {
        const apiCall = canWireApi ? matchHookToApiCall(action, expandedRoutes, ctx) : null;
        if (apiCall) {
          lines.push(`  ${apiCall}`);
        } else {
          lines.push(`  console.log('${action}', ${dep}); // TODO: ${action}`);
        }
      }
      lines.push(`}, [${dep}]);`);
    }
    lines.push('');
  }
  return lines;
}

/**
 * Match a hook action like `~api.stats` to an API client call.
 * Returns e.g. `api.getStats().then(data => setStats(data)).catch(console.error);`
 * or null if no match found.
 */
function matchHookToApiCall(
  action: string,
  expandedRoutes: import('../parser/types.js').AirRoute[],
  ctx: TranspileContext,
): string | null {
  // Only handle ~api.{resource} pattern
  if (!action.startsWith('~api.')) return null;

  const resource = action.slice(5); // e.g., 'stats', 'projects', 'users'

  // Find matching GET route where path ends with /{resource}
  const getRoute = expandedRoutes.find(r =>
    r.method === 'GET' && r.path.endsWith(`/${resource}`)
  );
  if (!getRoute) return null;

  const fnName = routeToFunctionName('GET', getRoute.path);

  // Find matching state setter — look for state field matching resource name
  const stateField = ctx.state.find(f => f.name === resource);
  if (!stateField) return null;

  const setter = `set${resource.charAt(0).toUpperCase() + resource.slice(1)}`;

  return `api.${fnName}().then(data => ${setter}(data)).catch(console.error);`;
}

// ---- Mutation-to-Route Matching ----

interface MutationRouteMatch {
  fnName: string;        // e.g. 'createTodo'
  method: string;        // e.g. 'POST'
  refetchFnName: string | null;  // e.g. 'getTodos'
  refetchSetter: string | null;  // e.g. 'setItems'
}

/**
 * Match a mutation name to an API route for fullstack wiring.
 * Returns the API function name, HTTP method, and refetch info, or null if no match.
 */
function findMatchingRoute(
  mutName: string,
  expandedRoutes: import('../parser/types.js').AirRoute[],
  ctx: TranspileContext,
): MutationRouteMatch | null {
  let matchedRoute: import('../parser/types.js').AirRoute | undefined;

  if (mutName === 'add' || mutName === 'addItem') {
    matchedRoute = expandedRoutes.find(r =>
      r.method === 'POST' && /~db\.\w+\.create/.test(r.handler)
    );
  } else if (mutName === 'del' || mutName === 'delItem' || mutName === 'remove') {
    matchedRoute = expandedRoutes.find(r =>
      r.method === 'DELETE' && /~db\.\w+\.delete/.test(r.handler)
    );
  } else if (mutName === 'toggle') {
    matchedRoute = expandedRoutes.find(r =>
      r.method === 'PUT' && /~db\.\w+\.update/.test(r.handler)
    );
  } else if (mutName === 'login') {
    matchedRoute = expandedRoutes.find(r =>
      r.method === 'POST' && r.path.endsWith('/login')
    );
  } else if (mutName === 'signup' || mutName === 'register') {
    matchedRoute = expandedRoutes.find(r =>
      r.method === 'POST' && (r.path.endsWith('/signup') || r.path.endsWith('/register'))
    );
  } else if (mutName === 'logout') {
    matchedRoute = expandedRoutes.find(r =>
      r.method === 'POST' && r.path.endsWith('/logout')
    );
  }

  if (!matchedRoute) return null;

  const fnName = routeToFunctionName(matchedRoute.method, matchedRoute.path);

  // Find refetch: GET route on the same base path
  const basePath = matchedRoute.path.replace(/\/:[^/]+$/, '');
  const getRoute = expandedRoutes.find(r =>
    r.method === 'GET' && r.path === basePath
  );
  const refetchFnName = getRoute ? routeToFunctionName('GET', getRoute.path) : null;

  // Resolve state setter for refetch
  let refetchSetter: string | null = null;
  if (refetchFnName) {
    // 1. Direct name match: /todos → state field 'todos' → setTodos
    const resource = basePath.replace(/^\//, '').split('/').pop() || '';
    const directMatch = ctx.state.find(f => f.name === resource);
    if (directMatch) {
      refetchSetter = 'set' + capitalize(directMatch.name);
    } else {
      // 2. Single array fallback
      const arrays = ctx.state.filter(f => f.type.kind === 'array');
      if (arrays.length === 1) {
        refetchSetter = 'set' + capitalize(arrays[0].name);
      }
    }
  }

  return { fnName, method: matchedRoute.method, refetchFnName, refetchSetter };
}

// ---- Root JSX ----

function generateRootJSX(ctx: TranspileContext, analysis: UIAnalysis): string[] {
  const rootClasses = 'min-h-screen bg-[var(--bg)] text-[var(--fg)]';

  const maxWidth = ctx.style.maxWidth;

  // Check for sidebar + main layout
  const hasSidebar = ctx.uiNodes.some(n =>
    n.kind === 'element' && n.element === 'sidebar'
  );

  // Determine wrapper: explicit maxWidth > sidebar (no wrapper) > default 900px container
  const wrapperClass = maxWidth
    ? `max-w-[${maxWidth}px] mx-auto space-y-6`
    : hasSidebar
      ? ''
      : 'max-w-[900px] mx-auto px-6 py-8 space-y-6';

  const lines: string[] = [];
  lines.push(`<div className="${rootClasses}">`);

  if (hasSidebar) {
    lines.push('  <div className="flex min-h-screen">');
  } else if (wrapperClass) {
    lines.push(`  <div className="${wrapperClass}">`);
  }

  const contentIndent = hasSidebar || wrapperClass ? 4 : 2;

  for (const node of ctx.uiNodes) {
    const jsx = generateJSX(node, ctx, analysis, ROOT_SCOPE, contentIndent);
    if (jsx) lines.push(jsx);
  }

  if (hasSidebar || wrapperClass) {
    lines.push('  </div>');
  }

  lines.push('</div>');
  return lines;
}

// ---- Core JSX Generator ----

function generateJSX(
  node: AirUINode,
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  switch (node.kind) {
    case 'text':
      return `${pad}{${interpolateText(node.text, ctx, scope)}}`;

    case 'value':
      return `${pad}{${JSON.stringify(node.value)}}`;

    case 'element':
      return generateElementJSX(node, ctx, analysis, scope, ind);

    case 'scoped':
      return generateScopedJSX(node, ctx, analysis, scope, ind);

    case 'unary':
      return generateUnaryJSX(node, ctx, analysis, scope, ind);

    case 'binary':
      return generateBinaryJSX(node, ctx, analysis, scope, ind);
  }
}

// ---- Element JSX ----

function generateElementJSX(
  node: AirUINode & { kind: 'element' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const mapping = mapElement(node.element, []);

  // Special elements
  if (node.element === 'tabs') {
    return generateTabsElement(node, ctx, analysis, scope, ind);
  }
  if (node.element === 'pagination') {
    return `${pad}<div className="flex gap-2 items-center justify-center mt-4">\n${pad}  <button className="px-3 py-1 rounded border border-[var(--border-input)] hover:bg-[var(--hover)]">&laquo; Prev</button>\n${pad}  <span className="px-3 py-1">1</span>\n${pad}  <button className="px-3 py-1 rounded border border-[var(--border-input)] hover:bg-[var(--hover)]">Next &raquo;</button>\n${pad}</div>`;
  }
  if (node.element === 'spinner') {
    return `${pad}<div className="${mapping.className}"></div>`;
  }
  if (node.element === 'logo') {
    return `${pad}<div className="${mapping.className}">&#9889;</div>`;
  }
  if (node.element === 'table') {
    return generateTableElement(node, ctx, analysis, scope, ind);
  }
  // stateVar.select → select dropdown for enum state
  if (node.element.endsWith('.select')) {
    const stateVar = node.element.replace('.select', '');
    const stateField = findStateField(stateVar, ctx);
    const options = stateField?.type.kind === 'enum' ? stateField.type.values : [];
    if (options.length > 0) {
      return `${pad}<select className="border border-[var(--border-input)] rounded-[var(--radius)] px-3 py-2 bg-transparent" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
        + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
        + `${pad}</select>`;
    }
  }

  // Grid element with first child as modifier (grid:3 appears as first child)
  if (node.element === 'grid' && node.children && node.children.length > 0) {
    let gridChildren = node.children;
    let gridMapping = mapping;
    const first = gridChildren[0];
    if (first.kind === 'binary' && first.operator === ':') {
      const bindRes = resolveBindChain(first);
      if (bindRes && bindRes.element === 'grid' && bindRes.binding?.kind === 'value') {
        const cols = String(bindRes.binding.value);
        gridMapping = mapElement('grid', [cols]);
        gridChildren = gridChildren.slice(1);
      }
    }
    // Wrap compose (+) children in a div so each becomes one grid cell
    const childJsx = gridChildren.map(c => {
      if (c.kind === 'binary' && c.operator === '+') {
        const inner = generateJSX(c, ctx, analysis, scope, ind + 4);
        return `${pad}  <div className="flex flex-col gap-4">\n${inner}\n${pad}  </div>`;
      }
      return generateJSX(c, ctx, analysis, scope, ind + 2);
    }).filter(Boolean).join('\n');
    return `${pad}<${gridMapping.tag} className="${gridMapping.className}">\n${childJsx}\n${pad}</${gridMapping.tag}>`;
  }

  // Plan element — render as pricing card with structured children
  if (node.element === 'plan' && node.children && node.children.length > 0) {
    return generatePlanElement(node, ctx, analysis, scope, ind);
  }

  // Stat grid: row of all stat children → responsive grid
  if (node.element === 'row' && node.children && node.children.length > 1) {
    const allStats = node.children.every(c => {
      const resolved = tryResolveElement(c);
      if (resolved && resolved.element === 'stat') return true;
      // Walk through flow (>) chains to detect stat
      if (c.kind === 'binary' && c.operator === '>') {
        const leftResolved = tryResolveElement(c.left);
        if (leftResolved && leftResolved.element === 'stat') return true;
      }
      return false;
    });
    if (allStats) {
      const cols = node.children.length;
      const gridClass = cols <= 2 ? 'grid grid-cols-2 gap-4'
        : cols <= 3 ? 'grid grid-cols-1 md:grid-cols-3 gap-4'
        : 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4';
      const childJsx = node.children.map(c =>
        generateJSX(c, ctx, analysis, scope, ind + 2)
      ).filter(Boolean).join('\n');
      return `${pad}<div className="${gridClass}">\n${childJsx}\n${pad}</div>`;
    }
  }

  // Element with children
  if (node.children && node.children.length > 0) {
    const childScope = node.element === 'form' ? { ...scope, insideForm: true } : scope;
    const childJsx = node.children.map(c =>
      generateJSX(c, ctx, analysis, childScope, ind + 2)
    ).filter(Boolean).join('\n');

    if (mapping.className) {
      return `${pad}<${mapping.tag} className="${mapping.className}">\n${childJsx}\n${pad}</${mapping.tag}>`;
    }
    return `${pad}<${mapping.tag}>\n${childJsx}\n${pad}</${mapping.tag}>`;
  }

  // Self-closing or empty
  if (mapping.selfClosing) {
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    const nameAttr = scope.insideForm ? ` name="${mapping.inputType || 'text'}"` : '';
    return `${pad}<${mapping.tag}${typeAttr}${nameAttr} className="${mapping.className}" />`;
  }

  if (mapping.className) {
    return `${pad}<${mapping.tag} className="${mapping.className}"></${mapping.tag}>`;
  }
  return `${pad}<${mapping.tag}></${mapping.tag}>`;
}

// ---- Scoped JSX (pages and sections) ----

function generateScopedJSX(
  node: AirUINode & { kind: 'scoped' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  if (node.scope === 'page') {
    // Detect if page is form-centric (login, signup, register, etc.) — center with card
    const isFormPage = pageHasFormContent(node);

    const childJsx = node.children.map(c =>
      generateJSX(c, ctx, analysis, scope, isFormPage ? ind + 8 : ind + 4)
    ).filter(Boolean).join('\n');

    if (isFormPage) {
      return `${pad}{currentPage === '${node.name}' && (\n`
        + `${pad}  <div className="flex items-center justify-center min-h-screen p-4">\n`
        + `${pad}    <div className="w-full max-w-md space-y-6 rounded-[var(--radius)] border border-[var(--border)] bg-[var(--surface)] p-8">\n`
        + `${pad}      <h2 className="text-2xl font-bold text-center">${capitalize(node.name)}</h2>\n`
        + `${childJsx}\n`
        + `${pad}    </div>\n`
        + `${pad}  </div>\n`
        + `${pad})}`;
    }

    return `${pad}{currentPage === '${node.name}' && (\n${pad}  <div>\n${childJsx}\n${pad}  </div>\n${pad})}`;
  }

  if (node.scope === 'section') {
    const childJsx = node.children.map(c =>
      generateJSX(c, ctx, analysis, scope, ind + 2)
    ).filter(Boolean).join('\n');

    return `${pad}<section id="${node.name}" className="py-16 px-6">\n${childJsx}\n${pad}</section>`;
  }

  return '';
}

function pageHasFormContent(node: AirUINode & { kind: 'scoped' }): boolean {
  for (const child of node.children) {
    if (child.kind === 'element' && child.element === 'form') return true;
    // form > !action pattern
    if (child.kind === 'binary' && child.operator === '>') {
      const left = child.left;
      if (left.kind === 'element' && left.element === 'form') return true;
      // Also check resolved element
      const resolved = tryResolveElement(left);
      if (resolved && resolved.element === 'form') return true;
    }
  }
  return false;
}

// ---- Unary JSX ----

function generateUnaryJSX(
  node: AirUINode & { kind: 'unary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  switch (node.operator) {
    case '#': {
      // State reference
      const expr = resolveRef(node.operand, scope);
      return `${pad}{${expr}}`;
    }

    case '!': {
      // Mutation — render as button with onClick
      const name = extractActionName(node.operand);
      const args = extractActionArgs(node.operand, scope);
      return `${pad}<button className="bg-[var(--accent)] text-white px-4 py-2 rounded-[var(--radius)] cursor-pointer hover:opacity-90 transition-colors" onClick={() => ${name}(${args})}>${name}</button>`;
    }

    case '*': {
      // Iteration
      return generateIterationJSX(node, ctx, analysis, scope, ind);
    }

    case '?': {
      // Conditional
      const condition = resolveRef(node.operand, scope);
      return `${pad}{${condition} && (`
        + `\n${pad}  ${generateJSX(node.operand, ctx, analysis, scope, ind + 2).trim()}`
        + `\n${pad})}`;
    }

    case '$': {
      // Currency display
      const inner = resolveRef(node.operand, scope);
      return `${pad}{'$' + (${inner}).toFixed(2)}`;
    }

    case '~': {
      // Async stub
      return `${pad}{/* TODO: async ${nodeToString(node.operand)} */}`;
    }

    case '^': {
      // Emit stub
      return `${pad}{/* TODO: emit ${nodeToString(node.operand)} */}`;
    }

    default:
      return `${pad}{/* unknown unary: ${node.operator} */}`;
  }
}

// ---- Binary JSX ----

function generateBinaryJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  switch (node.operator) {
    case '+':
      return generateComposeJSX(node, ctx, analysis, scope, ind);

    case '>':
      return generateFlowJSX(node, ctx, analysis, scope, ind);

    case '|':
      return generatePipeJSX(node, ctx, analysis, scope, ind);

    case ':':
      return generateBindJSX(node, ctx, analysis, scope, ind);

    case '.':
      return generateDotJSX(node, ctx, analysis, scope, ind);

    default:
      return `${pad}{/* unknown binary: ${node.operator} */}`;
  }
}

// ---- Compose (+) ----

function generateComposeJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Pattern: header>text + right → merge into header
  if (node.left.kind === 'binary' && node.left.operator === '>') {
    const leftResolved = tryResolveElement(node.left.left);
    if (leftResolved && leftResolved.element === 'header') {
      const mapping = mapElement('header', []);
      const rightResolved = tryResolveElement(node.right.kind === 'binary' && node.right.operator === ':' ? node.right : node.right);
      const isBadge = rightResolved && rightResolved.element === 'badge';
      const isAction = node.right.kind === 'unary' && node.right.operator === '!';
      const isBtn = rightResolved && (rightResolved.element === 'btn' || rightResolved.element === 'button');

      // Wrap header text in <h1>
      let titleJsx: string;
      if (node.left.right.kind === 'text') {
        titleJsx = `${pad}  <h1 className="text-xl font-bold">${escapeText(node.left.right.text)}</h1>`;
      } else {
        titleJsx = generateJSX(node.left.right, ctx, analysis, scope, ind + 2);
      }
      const rightContent = generateJSX(node.right, ctx, analysis, scope, isBadge ? ind + 4 : ind + 2);

      if (isBadge) {
        // Group title + badge together on the left
        return `${pad}<${mapping.tag} className="${mapping.className}">\n`
          + `${pad}  <div className="flex items-center gap-3">\n`
          + `${titleJsx.replace(new RegExp(`^${pad}  `), `${pad}    `)}\n`
          + `${rightContent.replace(new RegExp(`^(\\s*)`), `${pad}    `)}\n`
          + `${pad}  </div>\n`
          + `${pad}</${mapping.tag}>`;
      }
      return `${pad}<${mapping.tag} className="${mapping.className}">\n${titleJsx}\n${rightContent}\n${pad}</${mapping.tag}>`;
    }
  }

  const left = generateJSX(node.left, ctx, analysis, scope, ind);
  const right = generateJSX(node.right, ctx, analysis, scope, ind);
  return [left, right].filter(Boolean).join('\n');
}

// ---- Flow (>) ----

function generateFlowJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Pattern: ?condition > content → conditional rendering
  if (node.left.kind === 'unary' && node.left.operator === '?') {
    const condition = resolveRef(node.left.operand, scope);
    const content = generateJSX(node.right, ctx, analysis, scope, ind + 2);
    return `${pad}{${condition} && (\n${content}\n${pad})}`;
  }

  // Pattern: element > !mutation → element with event handler
  if (node.right.kind === 'unary' && node.right.operator === '!') {
    return generateElementWithAction(node.left, node.right, ctx, analysis, scope, ind);
  }

  // Pattern: element > *iter(...) → container with iteration
  if (node.right.kind === 'unary' && node.right.operator === '*') {
    // Check if left is itself a flow chain: list > (items|filter) then this > *iter
    const dataSource = extractDataSource(node.left, scope);
    return generateContainerWithIteration(node.left, dataSource, node.right, ctx, analysis, scope, ind);
  }

  // Pattern: element > text → element with text child
  if (node.right.kind === 'text') {
    const leftResolved = tryResolveElement(node.left);
    if (leftResolved) {
      const mapping = mapElement(leftResolved.element, leftResolved.modifiers);
      // img/a: text becomes src/href attribute, not children
      if (mapping.tag === 'img') {
        return `${pad}<img src="${node.right.text}"${classAttr(mapping.className)} alt="${leftResolved.modifiers[0] || 'image'}" />`;
      }
      if (mapping.tag === 'a') {
        const textContent = node.right.text;
        // Extract href from bind label (link:/signup > "Create account" → href="/signup", text="Create account")
        let href = '#';
        if (node.left.kind === 'binary' && node.left.operator === ':') {
          const bindInfo = resolveBindChain(node.left);
          if (bindInfo?.label) href = bindInfo.label;
        }
        // For page-based navigation, internal paths use setCurrentPage
        if (href.startsWith('/') && analysis.hasPages) {
          const pageName = href.slice(1);
          return `${pad}<a href="#"${classAttr(mapping.className)} onClick={(e) => { e.preventDefault(); setCurrentPage('${pageName}'); }}>${escapeText(textContent)}</a>`;
        }
        return `${pad}<a href="${href}"${classAttr(mapping.className)}>${escapeText(textContent)}</a>`;
      }
      const textContent = node.right.text.includes('#')
        ? `{${interpolateText(node.right.text, ctx, scope)}}`
        : escapeText(node.right.text);
      return `${pad}<${mapping.tag}${classAttr(mapping.className)}>${textContent}</${mapping.tag}>`;
    }
  }

  // Pattern: element > $#ref → element displaying currency value
  if (node.right.kind === 'unary' && node.right.operator === '$') {
    const leftResolved = tryResolveElement(node.left);
    if (leftResolved) {
      const inner = node.right.operand;
      const ref = resolveRef(inner.kind === 'unary' && inner.operator === '#' ? inner.operand : inner, scope);
      if (leftResolved.element === 'stat' && node.left.kind === 'binary' && node.left.operator === ':') {
        const bindInfo = resolveBindChain(node.left);
        if (bindInfo?.label) {
          const mapping = mapElement('stat', []);
          return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-xs font-medium text-[var(--muted)] uppercase tracking-wide">${escapeText(bindInfo.label)}</div>\n${pad}  <div className="text-2xl font-bold">{'$' + (${ref}).toFixed(2)}</div>\n${pad}</div>`;
        }
      }
      return `${pad}<span>{'$' + ${ref}}</span>`;
    }
  }

  // Pattern: element > #ref → element bound to / displaying state
  if (node.right.kind === 'unary' && node.right.operator === '#') {
    const leftResolved = tryResolveElement(node.left);
    if (leftResolved) {
      const ref = resolveRef(node.right.operand, scope);
      // For stat elements, extract the label from the bind chain
      if (leftResolved.element === 'stat' && node.left.kind === 'binary' && node.left.operator === ':') {
        const bindInfo = resolveBindChain(node.left);
        if (bindInfo?.label) {
          const mapping = mapElement('stat', []);
          return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-xs font-medium text-[var(--muted)] uppercase tracking-wide">${escapeText(bindInfo.label)}</div>\n${pad}  <div className="text-2xl font-bold">{${ref}}</div>\n${pad}</div>`;
        }
      }
      return generateFlowBoundElement(leftResolved, ref, ctx, scope, ind);
    }
  }

  // Pattern: element > binary(.) (state.property access or state.set pattern)
  if (node.right.kind === 'binary' && node.right.operator === '.') {
    return generateFlowWithDot(node.left, node.right, ctx, analysis, scope, ind);
  }

  // Pattern: element > binary(|) → element displaying piped value
  if (node.right.kind === 'binary' && node.right.operator === '|') {
    const leftResolved = tryResolveElement(node.left);
    if (leftResolved) {
      const mapping = mapElement(leftResolved.element, leftResolved.modifiers);
      const expr = resolvePipeExpr(node.right, ctx, scope);
      // Stat: show label + piped value
      if (leftResolved.element === 'stat') {
        const resolved = node.left.kind === 'binary' && node.left.operator === ':' ? resolveBindChain(node.left) : null;
        const label = resolved?.label || '';
        return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-xs font-medium text-[var(--muted)] uppercase tracking-wide">${escapeText(label)}</div>\n${pad}  <div className="text-2xl font-bold">{${expr}}</div>\n${pad}</div>`;
      }
      return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${expr}}</${mapping.tag}>`;
    }
  }

  // Pattern: element > stateVar.set(options) → tabs or select with setter
  if (node.right.kind === 'element' && node.right.element.includes('.set')) {
    return generateSetterElement(node.left, node.right, ctx, analysis, scope, ind);
  }

  // Pattern: element > stateVar.select → selector for enum state
  if (node.right.kind === 'element' && node.right.element.endsWith('.select')) {
    const stateVar = node.right.element.replace('.select', '');
    const stateField = findStateField(stateVar, ctx);
    const options = stateField?.type.kind === 'enum' ? stateField.type.values : [];
    return `${pad}<select className="border border-[var(--border-input)] rounded-[var(--radius)] px-3 py-2 bg-transparent" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
      + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
      + `${pad}</select>`;
  }

  // Pattern: nested flow chains (left is also a >)
  if (node.left.kind === 'binary' && node.left.operator === '>') {
    // Chain: a > b > c — the right side is nested content for the chain
    return generateFlowChain(node, ctx, analysis, scope, ind);
  }

  // Generic: left element, right as child
  const leftResolved = tryResolveElement(node.left);
  if (leftResolved) {
    const mapping = mapElement(leftResolved.element, leftResolved.modifiers);
    const childJsx = generateJSX(node.right, ctx, analysis, scope, ind + 2);
    return `${pad}<${mapping.tag}${classAttr(mapping.className)}>\n${childJsx}\n${pad}</${mapping.tag}>`;
  }

  // Fallback: render both sides
  const left = generateJSX(node.left, ctx, analysis, scope, ind);
  const right = generateJSX(node.right, ctx, analysis, scope, ind + 2);
  return `${left}\n${right}`;
}

// ---- Pipe (|) ----

function generatePipeJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // If left is a bind chain (e.g., badge:$#expenses | sum), extract element + pipe the value
  if (node.left.kind === 'binary' && node.left.operator === ':') {
    const resolved = resolveBindChain(node.left);
    if (resolved) {
      const mapping = mapElement(resolved.element, resolved.modifiers);
      // Build a pipe node using just the binding value as source
      const valueNode = resolved.binding || resolved.action || node.left;
      const pipeExpr = resolvePipeExpr({ kind: 'binary', operator: '|', left: valueNode, right: node.right }, ctx, scope);
      if (resolved.element === 'stat') {
        return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-xs font-medium text-[var(--muted)] uppercase tracking-wide">${escapeText(resolved.label || '')}</div>\n${pad}  <div className="text-2xl font-bold">{${pipeExpr}}</div>\n${pad}</div>`;
      }
      return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${pipeExpr}}</${mapping.tag}>`;
    }
  }

  const expr = resolvePipeExpr(node, ctx, scope);
  return `${pad}{${expr}}`;
}

// ---- Bind (:) ----

function generateBindJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const resolved = resolveBindChain(node);
  if (!resolved) {
    return `${pad}{/* unresolved bind */}`;
  }

  const mapping = mapElement(resolved.element, resolved.modifiers);

  // Progress bar: generate bar with percentage
  if (resolved.element === 'progress' && resolved.children && resolved.children.length > 0) {
    return generateProgressBar(resolved, ctx, scope, ind);
  }

  // Element with action
  if (resolved.action) {
    const actionName = extractActionName(resolved.action.kind === 'unary' ? resolved.action.operand : resolved.action);
    const actionArgs = extractActionArgs(
      resolved.action.kind === 'unary' ? resolved.action.operand : resolved.action,
      scope,
    );
    if (mapping.tag === 'button') {
      // Delete/remove actions inside iteration → compact icon button
      const isDel = actionName === 'del' || actionName === 'delete' || actionName === 'remove';
      let btnClass: string;
      if (isDel && scope.insideIter) {
        btnClass = mapElement('btn', ['icon']).className;
      } else if (resolved.element === 'btn' && resolved.modifiers.length === 0) {
        btnClass = mapElement('btn', ['ghost']).className;
      } else {
        btnClass = mapping.className;
      }
      return `${pad}<button className="${btnClass}" onClick={() => ${actionName}(${actionArgs})}>${getButtonLabel(resolved)}</button>`;
    }
    return `${pad}<${mapping.tag} className="${mapping.className}" onClick={() => ${actionName}(${actionArgs})} />`;
  }

  // Element with binding
  if (resolved.binding) {
    return generateBoundElement(resolved, mapping, ctx, analysis, scope, ind);
  }

  // Element with label (stat:"Total")
  if (resolved.label !== undefined) {
    if (resolved.element === 'stat') {
      return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-xs font-medium text-[var(--muted)] uppercase tracking-wide">${escapeText(resolved.label)}</div>\n${pad}  <div className="text-2xl font-bold">--</div>\n${pad}</div>`;
    }
    return `${pad}<${mapping.tag} className="${mapping.className}">${escapeText(resolved.label)}</${mapping.tag}>`;
  }

  // Nav with page items — render as navigation buttons
  if (resolved.element === 'nav' && resolved.children && resolved.children.length > 0 && analysis.hasPages) {
    const navItems = resolved.children.filter(c => c.kind === 'element').map(c => (c as AirUINode & { kind: 'element' }).element);
    if (navItems.length > 0) {
      const itemsJsx = navItems.map(name =>
        `${pad}  <button className={\`w-full text-left px-3 py-2 rounded-[var(--radius)] cursor-pointer transition-colors \${currentPage === '${name}' ? 'bg-[var(--accent)] text-white' : 'hover:bg-[var(--hover)]'}\`} onClick={() => setCurrentPage('${name}')}>${capitalize(name)}</button>`
      ).join('\n');
      return `${pad}<${mapping.tag}${classAttr(mapping.className)}>\n${itemsJsx}\n${pad}</${mapping.tag}>`;
    }
  }

  // Icon — render with emoji or modifier name
  if (resolved.element === 'icon') {
    const iconName = resolved.modifiers[0] || '';
    const emoji = ICON_EMOJI[iconName] || iconName;
    return `${pad}<span className="${mapping.className}">${emoji}</span>`;
  }

  // Chart — render placeholder
  if (resolved.element === 'chart') {
    return `${pad}<div className="${mapping.className}">${capitalize(resolved.modifiers[0] || 'chart')} chart placeholder</div>`;
  }

  // Element with children from resolved bind
  if (resolved.children && resolved.children.length > 0) {
    const childJsx = resolved.children.map(c =>
      generateJSX(c, ctx, analysis, scope, ind + 2)
    ).filter(Boolean).join('\n');
    return `${pad}<${mapping.tag}${classAttr(mapping.className)}>\n${childJsx}\n${pad}</${mapping.tag}>`;
  }

  // Simple styled element
  if (mapping.selfClosing) {
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    const nameAttr = scope.insideForm ? ` name="${mapping.inputType || resolved.element}"` : '';
    const placeholder = mapping.inputType && resolved.element === 'input'
      ? ` placeholder="${capitalize(mapping.inputType)}..."`
      : '';
    return `${pad}<${mapping.tag}${typeAttr}${nameAttr}${classAttr(mapping.className)}${placeholder} />`;
  }

  return `${pad}<${mapping.tag}${classAttr(mapping.className)}></${mapping.tag}>`;
}

// ---- Dot (.) ----

function generateDotJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Pattern: stateVar.select → select dropdown for enum state
  if (node.right.kind === 'element' && node.right.element === 'select') {
    const stateVar = node.left.kind === 'element' ? node.left.element : '';
    if (stateVar) {
      const stateField = findStateField(stateVar, ctx);
      const options = stateField?.type.kind === 'enum' ? stateField.type.values : [];
      if (options.length > 0) {
        return `${pad}<select className="border border-[var(--border-input)] rounded-[var(--radius)] px-3 py-2 bg-transparent" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
          + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
          + `${pad}</select>`;
      }
    }
  }

  const expr = resolveDotExpr(node, scope);
  return `${pad}{${expr}}`;
}

// ---- Helpers ----

function generateProgressBar(
  resolved: ResolvedBind,
  ctx: TranspileContext,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  // Extract value and max from children (which are config params like value:#expr, max:#expr)
  let valueExpr = '0';
  let maxExpr = '100';
  for (const child of resolved.children ?? []) {
    if (child.kind === 'binary' && child.operator === '|') {
      // Chained pipe: value:#expenses|sum(amount)
      // Left side is bind(value, #expenses), right side is sum(amount)
      if (child.left.kind === 'binary' && child.left.operator === ':') {
        const bindResolved = resolveBindChain(child.left);
        if (bindResolved && (bindResolved.element === 'value' || bindResolved.modifiers.includes('value'))) {
          const src = bindResolved.binding ? resolveRefNode(bindResolved.binding, scope) : '0';
          valueExpr = resolvePipeExprFromSourceAndRight(src, child.right, ctx, scope);
        }
      }
    } else if (child.kind === 'binary' && child.operator === ':') {
      const bindResolved = resolveBindChain(child);
      if (bindResolved) {
        if (bindResolved.element === 'value' && bindResolved.binding) {
          valueExpr = resolveRefNode(bindResolved.binding, scope);
        } else if (bindResolved.element === 'max' && bindResolved.binding) {
          maxExpr = resolveRefNode(bindResolved.binding, scope);
        }
      }
    }
  }
  return `${pad}<div className="w-full bg-[var(--hover)] rounded-full h-3 overflow-hidden">\n`
    + `${pad}  <div className="h-full bg-[var(--accent)] rounded-full transition-all" style={{ width: \`\${Math.min(100, (${valueExpr}) / (${maxExpr}) * 100)}%\` }}></div>\n`
    + `${pad}</div>`;
}

function resolvePipeExprFromSourceAndRight(src: string, right: AirUINode, ctx: TranspileContext, scope: Scope): string {
  if (right.kind === 'element') {
    const fn = right.element;
    const args = right.children?.map(c => c.kind === 'element' ? c.element : nodeToString(c)) ?? [];
    if (fn === 'sum' && args.length > 0) return `${src}.reduce((s, x) => s + x.${args[0]}, 0)`;
    if (fn === 'avg' && args.length > 0) return `(${src}.length ? ${src}.reduce((s, x) => s + x.${args[0]}, 0) / ${src}.length : 0)`;
  }
  return src;
}

function generateBoundElement(
  resolved: ResolvedBind,
  mapping: ReturnType<typeof mapElement>,
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const binding = resolved.binding!;

  // Checkbox bound to boolean
  if (resolved.element === 'check' || mapping.inputType === 'checkbox') {
    const ref = resolveRef(binding.kind === 'unary' ? binding.operand : binding, scope);
    if (scope.insideIter && scope.iterVar) {
      const arrayName = scope.baseArray || 'items';
      // Extract the boolean field name from the ref (e.g., "item.done" → "done")
      const boolField = ref.includes('.') ? ref.split('.').pop() : 'done';
      return `${pad}<input type="checkbox" checked={${ref}} onChange={() => ${setter(arrayName)}(prev => prev.map(_i => _i.id === ${scope.iterVar}.id ? { ..._i, ${boolField}: !_i.${boolField} } : _i))} />`;
    }
    return `${pad}<input type="checkbox" checked={${ref}} onChange={() => ${setter(ref)}(!${ref})} />`;
  }

  // Input bound to state
  if (mapping.tag === 'input' || resolved.element === 'search') {
    const ref = resolveRef(binding.kind === 'unary' ? binding.operand : binding, scope);
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    const resolvedFieldName = ref.includes('.') ? ref.split('.').pop()! : (resolved.modifiers[0] || resolved.element);
    const nameAttr = scope.insideForm ? ` name="${mapping.inputType || resolvedFieldName}"` : '';
    const inputJsx = `${pad}<input${typeAttr}${nameAttr} className="${mapping.className}" value={${ref}} onChange={(e) => ${resolveSetterFromRef(ref)}(e.target.value)} placeholder="${capitalize(resolved.modifiers[0] || resolved.element)}..." />`;
    if (scope.insideForm) {
      const label = deriveLabel(resolvedFieldName);
      return wrapFormGroup(inputJsx, label, pad);
    }
    return inputJsx;
  }

  // Select bound to state
  if (resolved.element === 'select') {
    const ref = resolveRef(binding.kind === 'unary' ? binding.operand : binding, scope);
    const stateField = findStateField(ref, ctx);
    const options = stateField?.type.kind === 'enum' ? stateField.type.values : [];
    const optionsJsx = options.map(o => `${pad}    <option value="${o}">${o}</option>`).join('\n');
    return `${pad}<select className="${mapping.className}" value={${ref}} onChange={(e) => ${resolveSetterFromRef(ref)}(e.target.value)}>\n${optionsJsx}\n${pad}</select>`;
  }

  // Badge showing value
  if (resolved.element === 'badge') {
    const ref = resolveRefNode(binding, scope);
    return `${pad}<span className="${mapping.className}">{${ref}}</span>`;
  }

  // Text/span showing value
  if (resolved.element === 'text' || resolved.element === 'p') {
    const ref = resolveRefNode(binding, scope);
    const hasCurrency = binding.kind === 'unary' && binding.operator === '$';
    // Inside iteration, text takes remaining space
    const iterClass = scope.insideIter ? ' flex-1' : '';
    const cls = mapping.className ? mapping.className + iterClass : iterClass.trim();
    if (hasCurrency) {
      const inner = resolveRef(binding.operand, scope);
      return `${pad}<${mapping.tag}${classAttr(cls)}>{'$' + ${inner}}</${mapping.tag}>`;
    }
    return `${pad}<${mapping.tag}${classAttr(cls)}>{${ref}}</${mapping.tag}>`;
  }

  // Stat element with label and value
  if (resolved.element === 'stat' && resolved.label !== undefined) {
    const ref = resolveRefNode(binding, scope);
    return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-xs font-medium text-[var(--muted)] uppercase tracking-wide">${escapeText(resolved.label)}</div>\n${pad}  <div className="text-2xl font-bold">{${ref}}</div>\n${pad}</div>`;
  }

  // Image with src
  if (resolved.element === 'img') {
    const src = binding.kind === 'text' ? binding.text
      : binding.kind === 'element' ? binding.element
      : nodeToString(binding);
    return `${pad}<img src="${src}" alt="${resolved.modifiers[0] || 'image'}" className="${mapping.className}" />`;
  }

  // Link with href
  if (resolved.element === 'link') {
    const href = binding.kind === 'text' ? binding.text
      : binding.kind === 'element' ? binding.element
      : '#';
    return `${pad}<a href="${href.startsWith('/') ? '#' + href : href}" className="${mapping.className}">`;
  }

  // Generic: render element displaying the binding value
  const ref = resolveRefNode(binding, scope);
  if (mapping.selfClosing) {
    return `${pad}<${mapping.tag}${classAttr(mapping.className)} value={${ref}} />`;
  }
  return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${ref}}</${mapping.tag}>`;
}

function generateElementWithAction(
  element: AirUINode,
  action: AirUINode & { kind: 'unary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const actionName = extractActionName(action.operand);
  const actionArgs = extractActionArgs(action.operand, scope);

  const resolved = tryResolveElement(element);
  if (!resolved) {
    return `${pad}<button onClick={() => ${actionName}(${actionArgs})}>${actionName}</button>`;
  }

  const mapping = mapElement(resolved.element, resolved.modifiers);

  // Form with submission
  if (resolved.element === 'form') {
    const formScope = { ...scope, insideForm: true };
    const childJsx = resolved.children
      ? resolved.children.map(c => generateJSX(c, ctx, analysis, formScope, ind + 2)).filter(Boolean).join('\n')
      : '';
    return `${pad}<form className="${mapping.className}" onSubmit={(e) => { e.preventDefault(); ${actionName}(${actionArgs}); }}>\n${childJsx}\n${pad}</form>`;
  }

  // Button with onClick
  if (mapping.tag === 'button') {
    const label = resolved.children
      ? resolved.children.map(c => {
          if (c.kind === 'text') return escapeText(c.text);
          return '';
        }).join('')
      : actionName;
    return `${pad}<button className="${mapping.className}" onClick={() => ${actionName}(${actionArgs})}>${label || actionName}</button>`;
  }

  // Input with onKeyDown enter handler + visible action button
  if (mapping.tag === 'input') {
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    const btnLabel = capitalize(actionName);
    // Button args: replace e.target.value with _inp.value (e.target in button context is the button, not the input)
    const btnArgs = actionArgs ? actionArgs.replace(/e\.target\.value/g, '_inp.value') : '_inp.value';
    return `${pad}<div className="flex gap-2">\n`
      + `${pad}  <input${typeAttr} className="${mapping.className} flex-1" placeholder="Add..." onKeyDown={(e) => { if (e.key === 'Enter' && e.target.value) { ${actionName}(${actionArgs || 'e.target.value'}); e.target.value = ''; } }} />\n`
      + `${pad}  <button className="bg-[var(--accent)] text-white px-4 py-2.5 rounded-[var(--radius)] cursor-pointer hover:opacity-90 transition-colors" onClick={(e) => { const _inp = e.currentTarget.previousElementSibling; if (_inp?.value) { ${actionName}(${btnArgs}); _inp.value = ''; } }}>${btnLabel}</button>\n`
      + `${pad}</div>`;
  }

  // Generic element with onClick
  const childJsx = resolved.children
    ? '\n' + resolved.children.map(c => generateJSX(c, ctx, analysis, scope, ind + 2)).filter(Boolean).join('\n') + '\n' + pad
    : '';
  return `${pad}<${mapping.tag}${classAttr(mapping.className)} onClick={() => ${actionName}(${actionArgs})}>${childJsx}</${mapping.tag}>`;
}

function generateIterationJSX(
  node: AirUINode & { kind: 'unary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Extract iteration variable name and children
  let iterVar = 'item';
  let children: AirUINode[] = [];
  if (node.operand.kind === 'element') {
    iterVar = node.operand.element;
    children = node.operand.children ?? [];
  }

  // Data source: look at parent context (passed from flow handler)
  const dataExpr = scope.iterData || 'items';
  const newScope: Scope = { iterVar, iterData: dataExpr, insideIter: true };

  const childJsx = children.map(c =>
    generateJSX(c, ctx, analysis, newScope, ind + 4)
  ).filter(Boolean).join('\n');

  return `${pad}{${dataExpr}.length === 0 ? (\n${pad}  <div className="empty-state">No items yet</div>\n${pad}) : ${dataExpr}.map((${iterVar}) => (\n${pad}  <div key={${iterVar}.id} className="flex gap-3 items-center bg-[var(--surface)] border border-[var(--border)] rounded-[var(--radius)] px-4 py-3">\n${childJsx}\n${pad}  </div>\n${pad}))}`;
}

function generateContainerWithIteration(
  leftNode: AirUINode,
  dataSource: string,
  iterNode: AirUINode & { kind: 'unary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Extract the container element from the left side
  let containerElement = 'div';
  let containerClass = '';

  if (leftNode.kind === 'binary' && leftNode.operator === '>') {
    // Chain: container > dataExpr
    const containerResolved = tryResolveElement(leftNode.left);
    if (containerResolved) {
      const mapping = mapElement(containerResolved.element, containerResolved.modifiers);
      containerElement = mapping.tag;
      containerClass = mapping.className;
    }
  } else {
    const containerResolved = tryResolveElement(leftNode);
    if (containerResolved) {
      const mapping = mapElement(containerResolved.element, containerResolved.modifiers);
      containerElement = mapping.tag;
      containerClass = mapping.className;
    }
  }

  // Generate iteration inside the container
  let iterVar = 'item';
  let children: AirUINode[] = [];
  if (iterNode.operand.kind === 'element') {
    iterVar = iterNode.operand.element;
    children = iterNode.operand.children ?? [];
  }

  // Extract base array name for mutations (e.g., "items" from "items.filter(...)")
  const baseArray = extractBaseArrayName(leftNode);
  const newScope: Scope = { iterVar, iterData: dataSource, baseArray, insideIter: true };

  const childJsx = children.map(c =>
    generateJSX(c, ctx, analysis, newScope, ind + 4)
  ).filter(Boolean).join('\n');

  return `${pad}<${containerElement}${classAttr(containerClass)}>\n`
    + `${pad}  {${dataSource}.length === 0 ? (\n`
    + `${pad}    <div className="empty-state">No items yet</div>\n`
    + `${pad}  ) : ${dataSource}.map((${iterVar}) => (\n`
    + `${pad}    <div key={${iterVar}.id} className="flex gap-3 items-center bg-[var(--surface)] border border-[var(--border)] rounded-[var(--radius)] px-4 py-3">\n`
    + `${childJsx}\n`
    + `${pad}    </div>\n`
    + `${pad}  ))}\n`
    + `${pad}</${containerElement}>`;
}

function generateFlowBoundElement(
  resolved: { element: string; modifiers: string[]; children?: AirUINode[] },
  stateRef: string,
  ctx: TranspileContext,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const mapping = mapElement(resolved.element, resolved.modifiers);
  const setterExpr = resolveSetterFromRef(stateRef);

  // Input: value + onChange
  if (mapping.tag === 'input' || resolved.element === 'search') {
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    const placeholder = resolved.modifiers[0] || resolved.element;
    const resolvedFieldName = stateRef.includes('.') ? stateRef.split('.').pop()! : (resolved.modifiers[0] || resolved.element);
    const nameAttr = scope.insideForm ? ` name="${mapping.inputType || resolvedFieldName}"` : '';
    const inputJsx = `${pad}<input${typeAttr}${nameAttr} className="${mapping.className}" value={${stateRef}} onChange={(e) => ${setterExpr}(e.target.value)} placeholder="${capitalize(placeholder)}..." />`;
    if (scope.insideForm) {
      const label = deriveLabel(resolvedFieldName);
      return wrapFormGroup(inputJsx, label, pad);
    }
    return inputJsx;
  }

  // Select: value + onChange with enum options
  if (resolved.element === 'select') {
    const enumValues = findEnumValues(stateRef, resolved.modifiers, ctx);
    const optionsJsx = enumValues.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n');
    return `${pad}<select className="${mapping.className}" value={${stateRef}} onChange={(e) => ${setterExpr}(e.target.value)}>\n${optionsJsx}\n${pad}</select>`;
  }

  // Tabs: generate button group from enum values
  if (resolved.element === 'tabs') {
    const enumValues = findEnumValues(stateRef, resolved.modifiers, ctx);
    if (enumValues.length > 0) {
      const optionsStr = enumValues.map(o => JSON.stringify(o)).join(', ');
      return `${pad}<div className="flex gap-1 p-1 bg-[var(--surface)] rounded-[var(--radius)]">\n`
        + `${pad}  {[${optionsStr}].map((_tab) => (\n`
        + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-[calc(var(--radius)-4px)] cursor-pointer transition-colors \${${stateRef} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent text-[var(--muted)] hover:text-[var(--fg)]'}\`} onClick={() => ${setterExpr}(_tab)}>{_tab}</button>\n`
        + `${pad}  ))}\n`
        + `${pad}</div>`;
    }
  }

  // Stat: display value
  if (resolved.element === 'stat') {
    const bindResolved = resolveBindChain({ kind: 'binary', operator: ':', left: { kind: 'element', element: resolved.element }, right: { kind: 'text', text: '' } } as any);
    return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-2xl font-bold">{${stateRef}}</div>\n${pad}</div>`;
  }

  // Generic: display value
  if (mapping.selfClosing) {
    return `${pad}<${mapping.tag}${classAttr(mapping.className)} value={${stateRef}} />`;
  }
  return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${stateRef}}</${mapping.tag}>`;
}

function findEnumValues(stateRef: string, modifiers: string[], ctx: TranspileContext): string[] {
  // Direct state field lookup
  const field = findStateField(stateRef, ctx);
  if (field) {
    const deepType = resolveDeepType(field.type, stateRef);
    if (deepType?.kind === 'enum' && deepType.values.length > 0) return deepType.values;
  }
  // Look for enum by modifier name (e.g., select:category → find category enum in any state field)
  for (const mod of modifiers) {
    for (const f of ctx.state) {
      const enumType = findEnumByName(f.type, mod);
      if (enumType) return enumType.values;
    }
  }
  return [];
}

function resolveDeepType(type: AirType, path: string): AirType | null {
  const parts = path.split('.');
  if (parts.length <= 1) return type;
  // Walk into object types
  let current = type;
  for (let i = 1; i < parts.length; i++) {
    if (current.kind === 'object') {
      const field = current.fields.find(f => f.name === parts[i]);
      if (field) { current = field.type; } else { return null; }
    } else if (current.kind === 'optional') {
      current = current.of;
      i--; // retry with inner type
    } else {
      return null;
    }
  }
  return current;
}

function findEnumByName(type: AirType, name: string): AirType & { kind: 'enum' } | null {
  if (type.kind === 'enum') return type;
  if (type.kind === 'array' && type.of.kind === 'object') {
    for (const f of type.of.fields) {
      if (f.name === name && f.type.kind === 'enum') return f.type;
    }
  }
  if (type.kind === 'object') {
    for (const f of type.fields) {
      if (f.name === name && f.type.kind === 'enum') return f.type;
    }
  }
  return null;
}

function generateSetterElement(
  leftNode: AirUINode,
  rightNode: AirUINode & { kind: 'element' },
  ctx: TranspileContext,
  _analysis: UIAnalysis,
  _scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const stateVar = rightNode.element.replace('.set', '');
  const options = rightNode.children?.map(c =>
    c.kind === 'element' ? c.element : nodeToString(c)
  ) ?? [];

  const leftResolved = tryResolveElement(leftNode);

  if (leftResolved?.element === 'tabs' || leftResolved?.element === 'row') {
    // Tabs: render buttons for each option
    const optionsStr = options.map(o => JSON.stringify(o)).join(', ');
    return `${pad}<div className="flex gap-1 p-1 bg-[var(--surface)] rounded-[var(--radius)]">\n`
      + `${pad}  {[${optionsStr}].map((_tab) => (\n`
      + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-[calc(var(--radius)-4px)] cursor-pointer transition-colors \${${stateVar} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent text-[var(--muted)] hover:text-[var(--fg)]'}\`} onClick={() => set${capitalize(stateVar)}(_tab)}>{_tab}</button>\n`
      + `${pad}  ))}\n`
      + `${pad}</div>`;
  }

  if (leftResolved?.element === 'select') {
    return `${pad}<select className="border border-[var(--border-input)] rounded-[var(--radius)] px-3 py-2 bg-transparent" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
      + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
      + `${pad}</select>`;
  }

  // Generic: render as tab buttons
  const optionsStr = options.map(o => JSON.stringify(o)).join(', ');
  return `${pad}<div className="flex gap-1 p-1 bg-[var(--surface)] rounded-[var(--radius)]">\n`
    + `${pad}  {[${optionsStr}].map((_tab) => (\n`
    + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-[calc(var(--radius)-4px)] cursor-pointer transition-colors \${${stateVar} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent text-[var(--muted)] hover:text-[var(--fg)]'}\`} onClick={() => set${capitalize(stateVar)}(_tab)}>{_tab}</button>\n`
    + `${pad}  ))}\n`
    + `${pad}</div>`;
}

function generateFlowWithDot(
  left: AirUINode,
  dot: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Pattern: tabs > filter.set(options) → tab buttons
  const leftResolved = tryResolveElement(left);
  if (dot.left.kind === 'element' && dot.right.kind === 'element' && dot.right.element === 'set') {
    const stateVar = dot.left.element;
    const options = dot.right.children?.map(c => c.kind === 'element' ? c.element : nodeToString(c)) ?? [];

    if (leftResolved?.element === 'tabs') {
      const optionsStr = options.map(o => JSON.stringify(o)).join(', ');
      return `${pad}<div className="flex gap-1 p-1 bg-[var(--surface)] rounded-[var(--radius)]">\n`
        + `${pad}  {[${optionsStr}].map((_tab) => (\n`
        + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-[calc(var(--radius)-4px)] cursor-pointer transition-colors \${${stateVar} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent text-[var(--muted)] hover:text-[var(--fg)]'}\`} onClick={() => set${capitalize(stateVar)}(_tab)}>{_tab}</button>\n`
        + `${pad}  ))}\n`
        + `${pad}</div>`;
    }

    // select > stateVar.set → select with options
    if (leftResolved?.element === 'select') {
      const mapping = mapElement('select', []);
      return `${pad}<select className="${mapping.className}" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
        + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
        + `${pad}</select>`;
    }
  }

  // Pattern: stateName.select → selector for enum state
  if (dot.right.kind === 'element' && dot.right.element === 'select') {
    const stateVar = dot.left.kind === 'element' ? dot.left.element : '';
    if (stateVar) {
      const stateField = findStateField(stateVar, ctx);
      const options = stateField?.type.kind === 'enum' ? stateField.type.values : [];
      return `${pad}<select className="border border-[var(--border-input)] rounded-[var(--radius)] px-3 py-2 bg-transparent" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
        + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
        + `${pad}</select>`;
    }
  }

  // Generic: render left with dot expression as child
  if (leftResolved) {
    const mapping = mapElement(leftResolved.element, leftResolved.modifiers);
    const expr = resolveDotExpr(dot, scope);
    return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${expr}}</${mapping.tag}>`;
  }

  return `${pad}{${resolveDotExpr(dot, scope)}}`;
}

function generateFlowChain(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Flatten the > chain
  const parts: AirUINode[] = [];
  let current: AirUINode = node;
  while (current.kind === 'binary' && current.operator === '>') {
    parts.push(current.right);
    current = current.left;
  }
  parts.push(current);
  parts.reverse();

  // parts[0] is the container, rest are content/data/iteration

  // Find container
  const containerResolved = tryResolveElement(parts[0]);

  // Find data source (pipe expressions)
  let dataExpr: string | null = null;
  for (let i = 1; i < parts.length; i++) {
    const part = parts[i];
    if (part.kind === 'binary' && part.operator === '|') {
      dataExpr = resolvePipeExpr(part, ctx, scope);
    } else if (part.kind === 'element') {
      // Could be a data reference (like 'items')
      const stateField = findStateField(part.element, ctx);
      if (stateField && stateField.type.kind === 'array') {
        dataExpr = stateField.name;
      }
    }
  }

  // Find iteration
  const iterPart = parts.find(p => p.kind === 'unary' && (p as AirUINode & { kind: 'unary' }).operator === '*');
  if (iterPart && iterPart.kind === 'unary') {
    // Extract base array name for mutations from data parts
    let baseArray = 'items';
    for (const p of parts) {
      if (p.kind === 'element') {
        const sf = findStateField(p.element, ctx);
        if (sf && sf.type.kind === 'array') { baseArray = sf.name; break; }
      }
    }
    const iterScope: Scope = { ...scope, iterData: dataExpr || baseArray, baseArray, insideIter: true };
    if (iterPart.operand.kind === 'element') {
      iterScope.iterVar = iterPart.operand.element;
    }

    const containerMapping = containerResolved ? mapElement(containerResolved.element, containerResolved.modifiers) : { tag: 'div', className: '' };

    let iterVar = iterScope.iterVar || 'item';
    let children = iterPart.operand.kind === 'element' ? (iterPart.operand.children ?? []) : [];

    const childJsx = children.map(c =>
      generateJSX(c, ctx, analysis, iterScope, ind + 4)
    ).filter(Boolean).join('\n');

    const iterDataExpr = dataExpr || 'items';
    return `${pad}<${containerMapping.tag}${classAttr(containerMapping.className)}>\n`
      + `${pad}  {${iterDataExpr}.length === 0 ? (\n`
      + `${pad}    <div className="empty-state">No items yet</div>\n`
      + `${pad}  ) : ${iterDataExpr}.map((${iterVar}) => (\n`
      + `${pad}    <div key={${iterVar}.id} className="flex gap-3 items-center bg-[var(--surface)] border border-[var(--border)] rounded-[var(--radius)] px-4 py-3">\n`
      + `${childJsx}\n`
      + `${pad}    </div>\n`
      + `${pad}  ))}\n`
      + `${pad}</${containerMapping.tag}>`;
  }

  // No iteration — just nested content
  const contentParts = parts.slice(1);
  const containerMapping = containerResolved ? mapElement(containerResolved.element, containerResolved.modifiers) : { tag: 'div', className: '' };
  const innerJsx = contentParts.map(c =>
    generateJSX(c, ctx, analysis, scope, ind + 2)
  ).filter(Boolean).join('\n');

  return `${pad}<${containerMapping.tag}${classAttr(containerMapping.className)}>\n${innerJsx}\n${pad}</${containerMapping.tag}>`;
}

function generateTableElement(
  node: AirUINode & { kind: 'element' },
  ctx: TranspileContext,
  _analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Extract column names and data source from children
  let columns: string[] = [];
  let dataSource = '';

  for (const child of node.children ?? []) {
    if (child.kind === 'binary' && child.operator === ':') {
      const resolved = resolveBindChain(child);
      if (resolved) {
        if (resolved.element === 'cols' && (resolved.binding || resolved.label)) {
          const rawText = resolved.label || (resolved.binding!.kind === 'text' ? resolved.binding!.text : nodeToString(resolved.binding!));
          columns = rawText.replace(/^\[+|\]+$/g, '').split(',').map(c => c.split(':')[0].trim()).filter(Boolean);
        } else if (resolved.element === 'data' && resolved.binding) {
          dataSource = resolveRefNode(resolved.binding, scope);
        }
      }
    }
    // data:#users|search — pipe wrapping a data bind
    if (child.kind === 'binary' && child.operator === '|') {
      if (child.left.kind === 'binary' && child.left.operator === ':') {
        const resolved = resolveBindChain(child.left);
        if (resolved?.element === 'data' && resolved.binding) {
          dataSource = resolvePipeExpr(child as AirUINode & { kind: 'binary' }, ctx, scope);
        }
      }
    }
  }

  if (columns.length === 0) columns = ['Column 1', 'Column 2', 'Column 3'];

  const headerCells = columns.map(c => `${pad}      <th>${capitalize(c)}</th>`).join('\n');
  const dataCells = columns.map(c => `${pad}          <td>{row.${c}}</td>`).join('\n');

  if (dataSource) {
    return `${pad}<table className="w-full">\n${pad}  <thead>\n${pad}    <tr>\n${headerCells}\n${pad}    </tr>\n${pad}  </thead>\n${pad}  <tbody>\n${pad}    {${dataSource}.length === 0 ? (\n${pad}      <tr><td colSpan={${columns.length}}><div className="empty-state">No items yet</div></td></tr>\n${pad}    ) : ${dataSource}.map((row) => (\n${pad}      <tr key={row.id}>\n${dataCells}\n${pad}      </tr>\n${pad}    ))}\n${pad}  </tbody>\n${pad}</table>`;
  }

  return `${pad}<table className="w-full">\n${pad}  <thead>\n${pad}    <tr>\n${headerCells}\n${pad}    </tr>\n${pad}  </thead>\n${pad}  <tbody>\n${pad}    <tr>\n${columns.map(c => `${pad}      <td>--</td>`).join('\n')}\n${pad}    </tr>\n${pad}  </tbody>\n${pad}</table>`;
}

function generatePlanElement(
  node: AirUINode & { kind: 'element' },
  _ctx: TranspileContext,
  _analysis: UIAnalysis,
  _scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const mapping = mapElement('plan', []);
  let name = '';
  let price = '';
  const features: string[] = [];

  for (const child of node.children ?? []) {
    if (child.kind === 'text') {
      const text = child.text;
      if (text.startsWith('[[') || text.startsWith('[')) {
        // Feature list: [[feat:5_apps,feat:community] → parse features
        const cleaned = text.replace(/^\[+|\]+$/g, '');
        for (const item of cleaned.split(',')) {
          const feat = item.trim().replace(/^feat:/, '').replace(/_/g, ' ');
          if (feat) features.push(feat);
        }
      } else if (!name) {
        name = text;
      }
    } else if (child.kind === 'value') {
      price = typeof child.value === 'number' ? (child.value === 0 ? 'Free' : `$${child.value}/mo`) : String(child.value);
    } else if (child.kind === 'element' && child.element === 'custom') {
      price = 'Custom';
    }
  }

  const lines = [`${pad}<div className="${mapping.className}">`];
  if (name) lines.push(`${pad}  <div className="text-lg font-semibold">${escapeText(name)}</div>`);
  if (price) lines.push(`${pad}  <div className="text-3xl font-bold">${escapeText(price)}</div>`);
  if (features.length > 0) {
    lines.push(`${pad}  <ul className="space-y-1 text-sm">`);
    for (const feat of features) {
      lines.push(`${pad}    <li>&#10004; ${escapeText(feat)}</li>`);
    }
    lines.push(`${pad}  </ul>`);
  }
  lines.push(`${pad}</div>`);
  return lines.join('\n');
}

function generateTabsElement(
  node: AirUINode & { kind: 'element' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // tabs with children that are just option elements
  if (node.children && node.children.length > 0) {
    const options = node.children.map(c => {
      if (c.kind === 'element') return c.element;
      return nodeToString(c);
    });

    // Try to find a filter state
    const filterField = ctx.state.find(f => f.type.kind === 'enum');
    if (filterField) {
      const optionsStr = options.map(o => JSON.stringify(o)).join(', ');
      return `${pad}<div className="flex gap-1 p-1 bg-[var(--surface)] rounded-[var(--radius)]">\n`
        + `${pad}  {[${optionsStr}].map((_tab) => (\n`
        + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-[calc(var(--radius)-4px)] cursor-pointer transition-colors \${${filterField.name} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent text-[var(--muted)] hover:text-[var(--fg)]'}\`} onClick={() => set${capitalize(filterField.name)}(_tab)}>{_tab}</button>\n`
        + `${pad}  ))}\n`
        + `${pad}</div>`;
    }
  }

  return `${pad}<div className="flex gap-1 p-1 bg-[var(--surface)] rounded-[var(--radius)]">{/* tabs */}</div>`;
}

// ---- Expression Resolvers ----

function resolveRef(node: AirUINode, scope: Scope): string {
  if (node.kind === 'element') {
    // Sanitize element name — strip trailing operators that shouldn't be in JS expressions
    const name = node.element.replace(/[-+*/]+$/, '');
    if (scope.insideIter && scope.iterVar && name === scope.iterVar) {
      return scope.iterVar;
    }
    return name;
  }
  if (node.kind === 'binary' && node.operator === '.') {
    const left = resolveRef(node.left, scope);
    const right = resolveRef(node.right, scope);
    return `${left}.${right}`;
  }
  if (node.kind === 'unary' && node.operator === '#') {
    return resolveRef(node.operand, scope);
  }
  if (node.kind === 'text') {
    return JSON.stringify(node.text);
  }
  if (node.kind === 'value') {
    return JSON.stringify(node.value);
  }
  return nodeToString(node);
}

function resolveRefNode(node: AirUINode, scope: Scope): string {
  if (node.kind === 'unary' && node.operator === '#') {
    return resolveRef(node.operand, scope);
  }
  if (node.kind === 'unary' && node.operator === '$') {
    const inner = resolveRefNode(node.operand, scope);
    return `'$' + ${inner}`;
  }
  if (node.kind === 'binary' && node.operator === '.') {
    return resolveDotExpr(node, scope);
  }
  if (node.kind === 'binary' && node.operator === '|') {
    return resolvePipeExprSimple(node, scope);
  }
  if (node.kind === 'binary' && node.operator === '-') {
    return `${resolveRefNode(node.left, scope)} - ${resolveRefNode(node.right, scope)}`;
  }
  return resolveRef(node, scope);
}

function resolveDotExpr(node: AirUINode & { kind: 'binary' }, scope: Scope): string {
  const left = resolveRef(node.left, scope);
  const right = node.right.kind === 'element' ? node.right.element : resolveRef(node.right, scope);
  return `${left}.${right}`;
}

function resolvePipeExpr(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  scope: Scope,
): string {
  const left = resolvePipeSource(node.left, ctx, scope);
  const right = node.right;

  if (right.kind === 'element') {
    const fn = right.element;
    const args = right.children?.map(c => c.kind === 'element' ? c.element : nodeToString(c)) ?? [];

    switch (fn) {
      case 'filter': {
        // Check if there's an enum filter state
        const filterField = ctx.state.find(f => f.name === 'filter' && f.type.kind === 'enum');
        if (filterField) {
          return `${left}.filter(_item => filter === 'all' || _item.category === filter || _item.done === (filter === 'done'))`;
        }
        return `${left}`;
      }
      case 'sort': {
        const sortField = ctx.state.find(f => f.name === 'sort');
        if (sortField) {
          return `[...${left}].sort((a, b) => sort === 'newest' ? b.id - a.id : sort === 'oldest' ? a.id - b.id : sort === 'highest' ? b.amount - a.amount : a.amount - b.amount)`;
        }
        return left;
      }
      case 'sum':
        if (args.length > 0) {
          return `${left}.reduce((s, x) => s + x.${args[0]}, 0)`;
        }
        return `${left}.reduce((s, x) => s + x, 0)`;
      case 'avg':
        if (args.length > 0) {
          return `(${left}.length ? ${left}.reduce((s, x) => s + x.${args[0]}, 0) / ${left}.length : 0)`;
        }
        return `(${left}.length ? ${left}.reduce((s, x) => s + x, 0) / ${left}.length : 0)`;
      case 'count':
        return `${left}.length`;
      case 'search': {
        return `${left}.filter(_item => Object.values(_item).some(v => String(v).toLowerCase().includes(search.toLowerCase())))`;
      }
      default:
        return `${left} /* |${fn} */`;
    }
  }

  // Chained pipes: left | right where right is also a pipe
  if (right.kind === 'binary' && right.operator === '|') {
    return resolvePipeExpr(
      { ...right, left: { kind: 'text', text: resolvePipeExpr({ kind: 'binary', operator: '|', left: node.left, right: right.left }, ctx, scope) } } as AirUINode & { kind: 'binary' },
      ctx,
      scope,
    );
  }

  return left;
}

function resolvePipeExprSimple(node: AirUINode & { kind: 'binary' }, scope: Scope): string {
  const left = resolveRefNode(node.left, scope);
  const right = node.right;

  if (right.kind === 'element') {
    const fn = right.element;
    const args = right.children?.map(c => c.kind === 'element' ? c.element : nodeToString(c)) ?? [];

    switch (fn) {
      case 'sum':
        return args.length > 0
          ? `${left}.reduce((s, x) => s + x.${args[0]}, 0)`
          : `${left}.reduce((s, x) => s + x, 0)`;
      case 'avg':
        return args.length > 0
          ? `(${left}.length ? ${left}.reduce((s, x) => s + x.${args[0]}, 0) / ${left}.length : 0)`
          : `(${left}.length ? ${left}.reduce((s, x) => s + x, 0) / ${left}.length : 0)`;
      default:
        return `${left}.${fn}`;
    }
  }

  return left;
}

function resolvePipeSource(node: AirUINode, ctx: TranspileContext, scope: Scope): string {
  if (node.kind === 'element') return node.element;
  if (node.kind === 'unary' && node.operator === '#') return resolveRef(node.operand, scope);
  if (node.kind === 'unary' && node.operator === '$') return resolvePipeSource(node.operand, ctx, scope);
  if (node.kind === 'binary' && node.operator === '.') return resolveDotExpr(node as AirUINode & { kind: 'binary' }, scope);
  if (node.kind === 'binary' && node.operator === '|') return resolvePipeExpr(node as AirUINode & { kind: 'binary' }, ctx, scope);
  if (node.kind === 'binary' && node.operator === ':') {
    // Bind chain — extract the binding value
    const resolved = resolveBindChain(node);
    if (resolved?.binding) return resolvePipeSource(resolved.binding, ctx, scope);
  }
  return nodeToString(node);
}

function extractDataSource(node: AirUINode, scope: Scope): string {
  // From a flow chain, extract the data expression
  if (node.kind === 'binary' && node.operator === '>') {
    // e.g., list > items|filter → data is from the right side
    return extractDataSource(node.right, scope);
  }
  if (node.kind === 'binary' && node.operator === '|') {
    // Pipe chain — recursively resolve left side for chained pipes
    const left = extractDataSource(node.left, scope);
    const right = node.right;
    if (right.kind === 'element') {
      const fn = right.element;
      if (fn === 'filter') {
        return `${left}.filter(_item => filter === 'all' || _item.category === filter || _item.done === (filter === 'done'))`;
      }
      if (fn === 'sort') {
        return `[...${left}].sort((a, b) => sort === 'newest' ? b.id - a.id : sort === 'oldest' ? a.id - b.id : sort === 'highest' ? b.amount - a.amount : a.amount - b.amount)`;
      }
      return `${left}`;
    }
    return left;
  }
  if (node.kind === 'element') {
    return node.element;
  }
  return 'items';
}

function extractActionName(node: AirUINode): string {
  if (node.kind === 'element') return node.element;
  if (node.kind === 'binary' && node.operator === '.') {
    const l = node.left.kind === 'element' ? node.left.element : '';
    const r = node.right.kind === 'element' ? node.right.element : '';
    return `${l}_${r}`;
  }
  return 'action';
}

function extractActionArgs(node: AirUINode, scope: Scope): string {
  if (node.kind === 'element' && node.children && node.children.length > 0) {
    return node.children.map(c => {
      if (c.kind === 'text') {
        // Raw text like {text:#val,done:false} — parse minimally
        let raw = c.text;
        // Parser may produce double braces — normalize to single pair
        if (raw.startsWith('{{') && !raw.startsWith('{{{')) {
          raw = raw.slice(1);
        }
        if (raw.startsWith('{')) {
          // Ensure closing brace
          if (!raw.endsWith('}')) raw = raw + '}';
          // Convert #val references
          return raw.replace(/#(\w+(?:\.\w+)*)/g, (_, name) => {
            if (name === 'val') return 'e.target.value';
            return scope.insideIter && scope.iterVar && name.startsWith(scope.iterVar + '.')
              ? name
              : name;
          });
        }
        // Raw text for array literals like [name,email,...]
        if (raw.startsWith('[')) {
          return raw;
        }
        return JSON.stringify(raw);
      }
      if (c.kind === 'unary' && c.operator === '#') {
        return resolveRef(c.operand, scope);
      }
      if (c.kind === 'binary' && c.operator === '.') {
        return resolveDotExpr(c as AirUINode & { kind: 'binary' }, scope);
      }
      return resolveRefNode(c, scope);
    }).join(', ');
  }
  return '';
}

interface ResolvedElement {
  element: string;
  modifiers: string[];
  children?: AirUINode[];
}

function tryResolveElement(node: AirUINode): ResolvedElement | null {
  if (node.kind === 'element') {
    return { element: node.element, modifiers: [], children: node.children };
  }
  if (node.kind === 'binary' && node.operator === ':') {
    const resolved = resolveBindChain(node);
    if (resolved) {
      return { element: resolved.element, modifiers: resolved.modifiers, children: resolved.children };
    }
  }
  return null;
}

// ---- Text Interpolation ----

function interpolateText(text: string, ctx: TranspileContext, scope: Scope): string {
  // Handle # references inside text strings
  if (text.includes('#')) {
    // Replace #var.prop and #var patterns with ${} expressions
    let result = text.replace(/#(\w+(?:\.\w+)*(?:\|[!]?\w+(?:\.\w+)*)*)/g, (_, ref) => {
      // Handle pipes in text refs like #items|!done.length
      const parts = ref.split('|');
      let expr = parts[0];

      // Use optional chaining if root state var is nullable
      const dotParts = expr.split('.');
      if (dotParts.length > 1) {
        const rootVar = dotParts[0];
        const stateField = ctx.state.find(f => f.name === rootVar);
        if (stateField && stateField.type.kind === 'optional') {
          expr = rootVar + '?.' + dotParts.slice(1).join('.');
        }
      }

      for (let i = 1; i < parts.length; i++) {
        const pipe = parts[i];
        if (pipe.startsWith('!')) {
          // Filter negation: !done → .filter(i => !i.done)
          const field = pipe.slice(1).split('.')[0];
          const rest = pipe.slice(1).split('.').slice(1).join('.');
          expr = `${expr}.filter(i => !i.${field})`;
          if (rest) expr = `${expr}.${rest}`;
        } else {
          expr = `${expr}.${pipe}`;
        }
      }
      return `\${${expr}}`;
    });
    return '`' + result + '`';
  }
  return JSON.stringify(text);
}

function escapeText(text: string): string {
  return text.replace(/[{}<>]/g, c => {
    switch (c) {
      case '{': return '&#123;';
      case '}': return '&#125;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      default: return c;
    }
  });
}

// ---- Utility ----

function deriveLabel(name: string): string {
  // snake_case → Title Case
  if (name.includes('_')) {
    return name.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
  }
  // camelCase → split on capitals
  const spaced = name.replace(/([a-z])([A-Z])/g, '$1 $2');
  return spaced.charAt(0).toUpperCase() + spaced.slice(1);
}

function wrapFormGroup(inputJsx: string, label: string, pad: string): string {
  return `${pad}<div className="form-group">\n${pad}  <label>${label}</label>\n${inputJsx.replace(/^(\s*)/, `${pad}  `)}\n${pad}</div>`;
}

function classAttr(className: string): string {
  return className ? ` className="${className}"` : '';
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function setter(name: string): string {
  return 'set' + capitalize(name);
}

function resolveSetterFromRef(ref: string): string {
  // ref could be 'input.title' → need setInput(prev => ({...prev, title: value}))
  const parts = ref.split('.');
  if (parts.length === 1) {
    return `set${capitalize(parts[0])}`;
  }
  // For nested: return a lambda
  // Actually return a string that the caller will use differently
  return `((v) => set${capitalize(parts[0])}(prev => ({ ...prev, ${parts.slice(1).join('.')}: v })))`;
}

function findStateField(name: string, ctx: TranspileContext): AirField | undefined {
  // Handle dotted names
  const baseName = name.split('.')[0];
  return ctx.state.find(f => f.name === baseName);
}

function nodeToString(node: AirUINode): string {
  switch (node.kind) {
    case 'text': return node.text;
    case 'value': return String(node.value);
    case 'element': return node.element;
    case 'unary': return `${node.operator}${nodeToString(node.operand)}`;
    case 'binary': return `${nodeToString(node.left)}${node.operator}${nodeToString(node.right)}`;
    case 'scoped': return `@${node.scope}:${node.name}`;
  }
}

function getButtonLabel(resolved: ResolvedBind): string {
  if (resolved.label) return escapeText(resolved.label);
  if (resolved.modifiers.includes('icon')) return '\u2715';
  // Check if action is a delete/remove → use ✕
  if (resolved.action) {
    const actionName = resolved.action.kind === 'unary'
      ? extractActionName(resolved.action.operand)
      : extractActionName(resolved.action);
    if (actionName === 'del' || actionName === 'delete' || actionName === 'remove') return '\u2715';
    return capitalize(actionName);
  }
  if (resolved.element === 'btn') return 'Submit';
  return resolved.element;
}

function extractBaseArrayName(node: AirUINode): string {
  if (node.kind === 'binary' && node.operator === '>') {
    return extractBaseArrayName(node.right);
  }
  if (node.kind === 'binary' && node.operator === '|') {
    return extractBaseArrayName(node.left);
  }
  if (node.kind === 'element') {
    return node.element;
  }
  return 'items';
}

function indent(lines: string[], n: number): string[] {
  const pad = ' '.repeat(n);
  return lines.flatMap(l => {
    if (!l) return [l];
    if (l.includes('\n')) {
      return l.split('\n').map(sub => sub ? pad + sub : sub);
    }
    return [pad + l];
  });
}
