/**
 * Core React Code Generator
 *
 * Walks the TranspileContext + UIAnalysis and emits a complete App.jsx
 * with useState, useEffect, mutation functions, and JSX.
 */

import type { AirUINode, AirField, AirType } from '../parser/types.js';
import type { TranspileContext } from './context.js';
import type { UIAnalysis, ResolvedBind } from './normalize-ui.js';
import { resolveBindChain } from './normalize-ui.js';
import { mapElement } from './element-map.js';

// ---- Scope tracking for code generation ----

interface Scope {
  iterVar?: string;
  iterData?: string;
  baseArray?: string;
  insideIter: boolean;
}

const ROOT_SCOPE: Scope = { insideIter: false };

// ---- Main entry ----

export function generateApp(ctx: TranspileContext, analysis: UIAnalysis): string {
  const lines: string[] = [];

  lines.push("import { useState, useEffect } from 'react';");
  lines.push('');
  lines.push(`// Generated by AirEngine from ${ctx.appName}.air`);
  lines.push('export default function App() {');

  // State declarations
  lines.push(...indent(generateStateDecls(ctx), 2));
  lines.push('');

  // Page navigation state (if pages exist)
  if (analysis.hasPages) {
    const defaultPage = analysis.pages[0]?.name ?? 'home';
    lines.push(`  const [currentPage, setCurrentPage] = useState('${defaultPage}');`);
    lines.push('');
  }

  // Persist: load on mount
  const loadCode = generatePersistLoad(ctx);
  if (loadCode.length) {
    lines.push(...indent(loadCode, 2));
    lines.push('');
  }

  // Persist: save on change
  const saveCode = generatePersistSave(ctx);
  if (saveCode.length) {
    lines.push(...indent(saveCode, 2));
    lines.push('');
  }

  // Mutation functions
  const mutCode = generateMutations(ctx, analysis);
  if (mutCode.length) {
    lines.push(...indent(mutCode, 2));
    lines.push('');
  }

  // Hook effects
  const hookCode = generateHookEffects(ctx);
  if (hookCode.length) {
    lines.push(...indent(hookCode, 2));
    lines.push('');
  }

  // JSX return
  lines.push('  return (');
  lines.push(...indent(generateRootJSX(ctx, analysis), 4));
  lines.push('  );');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

// ---- State Declarations ----

function generateStateDecls(ctx: TranspileContext): string[] {
  const lines: string[] = [];
  for (const field of ctx.state) {
    const defVal = defaultForType(field.type);
    const setter = 'set' + capitalize(field.name);
    lines.push(`const [${field.name}, ${setter}] = useState(${defVal});`);
  }
  return lines;
}

function defaultForType(type: AirType): string {
  switch (type.kind) {
    case 'str':
      return type.default !== undefined ? JSON.stringify(type.default) : "''";
    case 'int':
      return type.default !== undefined ? String(type.default) : '0';
    case 'float':
      return type.default !== undefined ? String(type.default) : '0';
    case 'bool':
      return type.default !== undefined ? String(type.default) : 'false';
    case 'date':
      return "''";
    case 'enum':
      return type.default !== undefined
        ? JSON.stringify(type.default)
        : JSON.stringify(type.values[0] ?? '');
    case 'array':
      return '[]';
    case 'object':
      return generateObjectDefault(type.fields);
    case 'optional':
      return 'null';
    case 'ref':
      return 'null';
  }
}

function generateObjectDefault(fields: AirField[]): string {
  const entries = fields.map(f => `${f.name}: ${defaultForType(f.type)}`);
  return `{ ${entries.join(', ')} }`;
}

// ---- Persist: Load ----

function generatePersistLoad(ctx: TranspileContext): string[] {
  if (ctx.persistKeys.length === 0) return [];

  const lines: string[] = [];

  if (ctx.persistMethod === 'localStorage' || ctx.persistMethod === 'session') {
    const storage = ctx.persistMethod === 'session' ? 'sessionStorage' : 'localStorage';
    lines.push('useEffect(() => {');
    lines.push('  try {');
    for (const key of ctx.persistKeys) {
      const safeName = key.replace(/\./g, '_');
      const setter = 'set' + capitalize(safeName);
      lines.push(`    const saved_${safeName} = ${storage}.getItem('${ctx.appName}-${safeName}');`);
      lines.push(`    if (saved_${safeName}) ${setter}(JSON.parse(saved_${safeName}));`);
    }
    lines.push('  } catch (e) { /* ignore corrupt storage */ }');
    lines.push('}, []);');
  } else if (ctx.persistMethod === 'cookie') {
    // Cookie persistence — warning for httpOnly
    if (ctx.persistOptions.httpOnly) {
      lines.push('// WARNING: httpOnly cookies require server-side handling');
    }
    lines.push('useEffect(() => {');
    lines.push('  try {');
    lines.push('    const cookies = Object.fromEntries(document.cookie.split("; ").map(c => c.split("=")));');
    for (const key of ctx.persistKeys) {
      const safeName = key.replace(/\./g, '_');
      const setter = 'set' + capitalize(safeName);
      lines.push(`    if (cookies['${ctx.appName}-${safeName}']) ${setter}(JSON.parse(decodeURIComponent(cookies['${ctx.appName}-${safeName}'])));`);
    }
    lines.push('  } catch (e) { /* ignore */ }');
    lines.push('}, []);');
  }

  return lines;
}

// ---- Persist: Save ----

function generatePersistSave(ctx: TranspileContext): string[] {
  if (ctx.persistKeys.length === 0) return [];

  const lines: string[] = [];

  if (ctx.persistMethod === 'localStorage' || ctx.persistMethod === 'session') {
    const storage = ctx.persistMethod === 'session' ? 'sessionStorage' : 'localStorage';
    for (const key of ctx.persistKeys) {
      const safeName = key.replace(/\./g, '_');
      lines.push(`useEffect(() => {`);
      lines.push(`  ${storage}.setItem('${ctx.appName}-${safeName}', JSON.stringify(${safeName}));`);
      lines.push(`}, [${safeName}]);`);
    }
  } else if (ctx.persistMethod === 'cookie') {
    const maxAge = ctx.persistOptions['7d'] ? '; max-age=604800' : '';
    for (const key of ctx.persistKeys) {
      const safeName = key.replace(/\./g, '_');
      lines.push(`useEffect(() => {`);
      lines.push(`  document.cookie = '${ctx.appName}-${safeName}=' + encodeURIComponent(JSON.stringify(${safeName})) + '; path=/${maxAge}';`);
      lines.push(`}, [${safeName}]);`);
    }
  }

  return lines;
}

// ---- Mutation Functions ----

function generateMutations(ctx: TranspileContext, analysis: UIAnalysis): string[] {
  const lines: string[] = [];
  const arrayField = ctx.state.find(f => f.type.kind === 'array');
  const arrayName = arrayField?.name;

  for (const mut of analysis.mutations) {
    const name = mut.name;

    if (name === 'add' || name === 'addItem') {
      if (arrayName) {
        lines.push(`const ${name} = (data) => {`);
        lines.push(`  ${setter(arrayName)}(prev => [...prev, { ...data, id: Date.now() }]);`);
        lines.push('};');
      }
    } else if (name === 'del' || name === 'delItem' || name === 'remove') {
      if (arrayName) {
        lines.push(`const ${name} = (id) => {`);
        lines.push(`  ${setter(arrayName)}(prev => prev.filter(item => item.id !== id));`);
        lines.push('};');
      }
    } else if (name === 'toggle') {
      if (arrayName) {
        lines.push(`const ${name} = (id, field) => {`);
        lines.push(`  ${setter(arrayName)}(prev => prev.map(item => item.id === id ? { ...item, [field]: !item[field] } : item));`);
        lines.push('};');
      }
    } else if (name === 'login') {
      lines.push(`const login = async (e) => {`);
      lines.push(`  e?.preventDefault?.();`);
      lines.push(`  setLoading(true);`);
      lines.push(`  setError(null);`);
      lines.push(`  try {`);
      lines.push(`    // TODO: Replace with actual API call`);
      lines.push(`    console.log('Login attempted');`);
      lines.push(`    setUser({ name: 'User', email: 'user@example.com', token: 'mock-token' });`);
      lines.push(`    setCurrentPage('dashboard');`);
      lines.push(`  } catch (err) {`);
      lines.push(`    setError(err.message || 'Login failed');`);
      lines.push(`  } finally {`);
      lines.push(`    setLoading(false);`);
      lines.push(`  }`);
      lines.push('};');
    } else if (name === 'logout') {
      lines.push(`const logout = () => {`);
      lines.push(`  setUser(null);`);
      lines.push(`  setCurrentPage('login');`);
      lines.push('};');
    } else if (name === 'signup') {
      lines.push(`const signup = async (e) => {`);
      lines.push(`  e?.preventDefault?.();`);
      lines.push(`  setLoading(true);`);
      lines.push(`  setError(null);`);
      lines.push(`  try {`);
      lines.push(`    console.log('Signup attempted');`);
      lines.push(`    setCurrentPage('login');`);
      lines.push(`  } catch (err) {`);
      lines.push(`    setError(err.message || 'Signup failed');`);
      lines.push(`  } finally {`);
      lines.push(`    setLoading(false);`);
      lines.push(`  }`);
      lines.push('};');
    } else {
      // Generic mutation stub
      lines.push(`const ${name.replace(/\./g, '_')} = (...args) => {`);
      lines.push(`  console.log('${name}', ...args);`);
      lines.push('};');
    }
    lines.push('');
  }

  return lines;
}

// ---- Hook Effects ----

function generateHookEffects(ctx: TranspileContext): string[] {
  if (ctx.hooks.length === 0) return [];

  const lines: string[] = [];
  for (const hook of ctx.hooks) {
    if (hook.trigger === 'onMount') {
      lines.push('useEffect(() => {');
      for (const action of hook.actions) {
        lines.push(`  console.log('${action}'); // TODO: ${action}`);
      }
      lines.push('}, []);');
    } else if (hook.trigger.startsWith('onChange:')) {
      const dep = hook.trigger.split(':')[1];
      lines.push(`useEffect(() => {`);
      for (const action of hook.actions) {
        lines.push(`  console.log('${action}', ${dep}); // TODO: ${action}`);
      }
      lines.push(`}, [${dep}]);`);
    }
    lines.push('');
  }
  return lines;
}

// ---- Root JSX ----

function generateRootJSX(ctx: TranspileContext, analysis: UIAnalysis): string[] {
  const theme = ctx.style.theme;
  const isDark = theme === 'dark' || theme === undefined;

  const rootClasses = isDark
    ? 'min-h-screen bg-gray-950 text-gray-100'
    : 'min-h-screen bg-white text-gray-900';

  const maxWidth = ctx.style.maxWidth;
  const wrapperClass = maxWidth ? ` max-w-[${maxWidth}px] mx-auto` : '';

  const lines: string[] = [];
  lines.push(`<div className="${rootClasses}">`);

  if (wrapperClass) {
    lines.push(`  <div className="${wrapperClass.trim()}">`);
  }

  // Check for sidebar + main layout
  const hasSidebar = ctx.uiNodes.some(n =>
    n.kind === 'element' && n.element === 'sidebar'
  );

  if (hasSidebar) {
    lines.push('  <div className="flex min-h-screen">');
  }

  for (const node of ctx.uiNodes) {
    const jsx = generateJSX(node, ctx, analysis, ROOT_SCOPE, hasSidebar ? 4 : wrapperClass ? 4 : 2);
    if (jsx) lines.push(jsx);
  }

  if (hasSidebar) {
    lines.push('  </div>');
  }

  if (wrapperClass) {
    lines.push('  </div>');
  }

  lines.push('</div>');
  return lines;
}

// ---- Core JSX Generator ----

function generateJSX(
  node: AirUINode,
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  switch (node.kind) {
    case 'text':
      return `${pad}{${interpolateText(node.text, ctx, scope)}}`;

    case 'value':
      return `${pad}{${JSON.stringify(node.value)}}`;

    case 'element':
      return generateElementJSX(node, ctx, analysis, scope, ind);

    case 'scoped':
      return generateScopedJSX(node, ctx, analysis, scope, ind);

    case 'unary':
      return generateUnaryJSX(node, ctx, analysis, scope, ind);

    case 'binary':
      return generateBinaryJSX(node, ctx, analysis, scope, ind);
  }
}

// ---- Element JSX ----

function generateElementJSX(
  node: AirUINode & { kind: 'element' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const mapping = mapElement(node.element, []);

  // Special elements
  if (node.element === 'tabs') {
    return generateTabsElement(node, ctx, analysis, scope, ind);
  }
  if (node.element === 'pagination') {
    return `${pad}<div className="flex gap-2 items-center justify-center mt-4">\n${pad}  <button className="px-3 py-1 rounded border border-white/20 hover:bg-white/10">&laquo; Prev</button>\n${pad}  <span className="px-3 py-1">1</span>\n${pad}  <button className="px-3 py-1 rounded border border-white/20 hover:bg-white/10">Next &raquo;</button>\n${pad}</div>`;
  }
  if (node.element === 'spinner') {
    return `${pad}<div className="${mapping.className}"></div>`;
  }
  if (node.element === 'logo') {
    return `${pad}<div className="${mapping.className}">&#9889;</div>`;
  }

  // Element with children
  if (node.children && node.children.length > 0) {
    const childJsx = node.children.map(c =>
      generateJSX(c, ctx, analysis, scope, ind + 2)
    ).filter(Boolean).join('\n');

    if (mapping.className) {
      return `${pad}<${mapping.tag} className="${mapping.className}">\n${childJsx}\n${pad}</${mapping.tag}>`;
    }
    return `${pad}<${mapping.tag}>\n${childJsx}\n${pad}</${mapping.tag}>`;
  }

  // Self-closing or empty
  if (mapping.selfClosing) {
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    return `${pad}<${mapping.tag}${typeAttr} className="${mapping.className}" />`;
  }

  if (mapping.className) {
    return `${pad}<${mapping.tag} className="${mapping.className}"></${mapping.tag}>`;
  }
  return `${pad}<${mapping.tag}></${mapping.tag}>`;
}

// ---- Scoped JSX (pages and sections) ----

function generateScopedJSX(
  node: AirUINode & { kind: 'scoped' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  if (node.scope === 'page') {
    const childJsx = node.children.map(c =>
      generateJSX(c, ctx, analysis, scope, ind + 4)
    ).filter(Boolean).join('\n');

    return `${pad}{currentPage === '${node.name}' && (\n${pad}  <div>\n${childJsx}\n${pad}  </div>\n${pad})}`;
  }

  if (node.scope === 'section') {
    const childJsx = node.children.map(c =>
      generateJSX(c, ctx, analysis, scope, ind + 2)
    ).filter(Boolean).join('\n');

    return `${pad}<section id="${node.name}" className="py-16 px-6">\n${childJsx}\n${pad}</section>`;
  }

  return '';
}

// ---- Unary JSX ----

function generateUnaryJSX(
  node: AirUINode & { kind: 'unary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  switch (node.operator) {
    case '#': {
      // State reference
      const expr = resolveRef(node.operand, scope);
      return `${pad}{${expr}}`;
    }

    case '!': {
      // Mutation — render as button with onClick
      const name = extractActionName(node.operand);
      const args = extractActionArgs(node.operand, scope);
      return `${pad}<button className="px-4 py-2 rounded-lg bg-[var(--accent)] text-white cursor-pointer hover:opacity-90" onClick={() => ${name}(${args})}>${name}</button>`;
    }

    case '*': {
      // Iteration
      return generateIterationJSX(node, ctx, analysis, scope, ind);
    }

    case '?': {
      // Conditional
      const condition = resolveRef(node.operand, scope);
      return `${pad}{${condition} && (`
        + `\n${pad}  ${generateJSX(node.operand, ctx, analysis, scope, ind + 2).trim()}`
        + `\n${pad})}`;
    }

    case '$': {
      // Currency display
      const inner = resolveRef(node.operand, scope);
      return `${pad}{'$' + (${inner}).toFixed(2)}`;
    }

    case '~': {
      // Async stub
      return `${pad}{/* TODO: async ${nodeToString(node.operand)} */}`;
    }

    case '^': {
      // Emit stub
      return `${pad}{/* TODO: emit ${nodeToString(node.operand)} */}`;
    }

    default:
      return `${pad}{/* unknown unary: ${node.operator} */}`;
  }
}

// ---- Binary JSX ----

function generateBinaryJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  switch (node.operator) {
    case '+':
      return generateComposeJSX(node, ctx, analysis, scope, ind);

    case '>':
      return generateFlowJSX(node, ctx, analysis, scope, ind);

    case '|':
      return generatePipeJSX(node, ctx, analysis, scope, ind);

    case ':':
      return generateBindJSX(node, ctx, analysis, scope, ind);

    case '.':
      return generateDotJSX(node, ctx, analysis, scope, ind);

    default:
      return `${pad}{/* unknown binary: ${node.operator} */}`;
  }
}

// ---- Compose (+) ----

function generateComposeJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const left = generateJSX(node.left, ctx, analysis, scope, ind);
  const right = generateJSX(node.right, ctx, analysis, scope, ind);
  return [left, right].filter(Boolean).join('\n');
}

// ---- Flow (>) ----

function generateFlowJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Pattern: element > !mutation → element with event handler
  if (node.right.kind === 'unary' && node.right.operator === '!') {
    return generateElementWithAction(node.left, node.right, ctx, analysis, scope, ind);
  }

  // Pattern: element > *iter(...) → container with iteration
  if (node.right.kind === 'unary' && node.right.operator === '*') {
    // Check if left is itself a flow chain: list > (items|filter) then this > *iter
    const dataSource = extractDataSource(node.left, scope);
    return generateContainerWithIteration(node.left, dataSource, node.right, ctx, analysis, scope, ind);
  }

  // Pattern: element > text → element with text child
  if (node.right.kind === 'text') {
    const leftResolved = tryResolveElement(node.left);
    if (leftResolved) {
      const mapping = mapElement(leftResolved.element, leftResolved.modifiers);
      const textContent = node.right.text.includes('#')
        ? `{${interpolateText(node.right.text, ctx, scope)}}`
        : escapeText(node.right.text);
      return `${pad}<${mapping.tag}${classAttr(mapping.className)}>${textContent}</${mapping.tag}>`;
    }
  }

  // Pattern: element > #ref → element bound to / displaying state
  if (node.right.kind === 'unary' && node.right.operator === '#') {
    const leftResolved = tryResolveElement(node.left);
    if (leftResolved) {
      const ref = resolveRef(node.right.operand, scope);
      // For stat elements, extract the label from the bind chain
      if (leftResolved.element === 'stat' && node.left.kind === 'binary' && node.left.operator === ':') {
        const bindInfo = resolveBindChain(node.left);
        if (bindInfo?.label) {
          const mapping = mapElement('stat', []);
          return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-sm opacity-70">${escapeText(bindInfo.label)}</div>\n${pad}  <div className="text-2xl font-bold">{${ref}}</div>\n${pad}</div>`;
        }
      }
      return generateFlowBoundElement(leftResolved, ref, ctx, scope, ind);
    }
  }

  // Pattern: element > binary(.) (state.property access or state.set pattern)
  if (node.right.kind === 'binary' && node.right.operator === '.') {
    return generateFlowWithDot(node.left, node.right, ctx, analysis, scope, ind);
  }

  // Pattern: element > binary(|) → element displaying piped value
  if (node.right.kind === 'binary' && node.right.operator === '|') {
    const leftResolved = tryResolveElement(node.left);
    if (leftResolved) {
      const mapping = mapElement(leftResolved.element, leftResolved.modifiers);
      const expr = resolvePipeExpr(node.right, ctx, scope);
      // Stat: show label + piped value
      if (leftResolved.element === 'stat') {
        const resolved = node.left.kind === 'binary' && node.left.operator === ':' ? resolveBindChain(node.left) : null;
        const label = resolved?.label || '';
        return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-sm opacity-70">${escapeText(label)}</div>\n${pad}  <div className="text-2xl font-bold">{${expr}}</div>\n${pad}</div>`;
      }
      return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${expr}}</${mapping.tag}>`;
    }
  }

  // Pattern: element > stateVar.set(options) → tabs or select with setter
  if (node.right.kind === 'element' && node.right.element.includes('.set')) {
    return generateSetterElement(node.left, node.right, ctx, analysis, scope, ind);
  }

  // Pattern: element > stateVar.select → selector for enum state
  if (node.right.kind === 'element' && node.right.element.endsWith('.select')) {
    const stateVar = node.right.element.replace('.select', '');
    const stateField = findStateField(stateVar, ctx);
    const options = stateField?.type.kind === 'enum' ? stateField.type.values : [];
    return `${pad}<select className="border border-white/20 rounded-lg px-3 py-2 bg-transparent" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
      + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
      + `${pad}</select>`;
  }

  // Pattern: nested flow chains (left is also a >)
  if (node.left.kind === 'binary' && node.left.operator === '>') {
    // Chain: a > b > c — the right side is nested content for the chain
    return generateFlowChain(node, ctx, analysis, scope, ind);
  }

  // Generic: left element, right as child
  const leftResolved = tryResolveElement(node.left);
  if (leftResolved) {
    const mapping = mapElement(leftResolved.element, leftResolved.modifiers);
    const childJsx = generateJSX(node.right, ctx, analysis, scope, ind + 2);
    return `${pad}<${mapping.tag}${classAttr(mapping.className)}>\n${childJsx}\n${pad}</${mapping.tag}>`;
  }

  // Fallback: render both sides
  const left = generateJSX(node.left, ctx, analysis, scope, ind);
  const right = generateJSX(node.right, ctx, analysis, scope, ind + 2);
  return `${left}\n${right}`;
}

// ---- Pipe (|) ----

function generatePipeJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // If left is a bind chain (e.g., badge:$#expenses | sum), extract element + pipe the value
  if (node.left.kind === 'binary' && node.left.operator === ':') {
    const resolved = resolveBindChain(node.left);
    if (resolved) {
      const mapping = mapElement(resolved.element, resolved.modifiers);
      // Build a pipe node using just the binding value as source
      const valueNode = resolved.binding || resolved.action || node.left;
      const pipeExpr = resolvePipeExpr({ kind: 'binary', operator: '|', left: valueNode, right: node.right }, ctx, scope);
      if (resolved.element === 'stat') {
        return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-sm opacity-70">${escapeText(resolved.label || '')}</div>\n${pad}  <div className="text-2xl font-bold">{${pipeExpr}}</div>\n${pad}</div>`;
      }
      return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${pipeExpr}}</${mapping.tag}>`;
    }
  }

  const expr = resolvePipeExpr(node, ctx, scope);
  return `${pad}{${expr}}`;
}

// ---- Bind (:) ----

function generateBindJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const resolved = resolveBindChain(node);
  if (!resolved) {
    return `${pad}{/* unresolved bind */}`;
  }

  const mapping = mapElement(resolved.element, resolved.modifiers);

  // Progress bar: generate bar with percentage
  if (resolved.element === 'progress' && resolved.children && resolved.children.length > 0) {
    return generateProgressBar(resolved, ctx, scope, ind);
  }

  // Element with action
  if (resolved.action) {
    const actionName = extractActionName(resolved.action.kind === 'unary' ? resolved.action.operand : resolved.action);
    const actionArgs = extractActionArgs(
      resolved.action.kind === 'unary' ? resolved.action.operand : resolved.action,
      scope,
    );
    if (mapping.tag === 'button') {
      return `${pad}<button className="${mapping.className}" onClick={() => ${actionName}(${actionArgs})}>${getButtonLabel(resolved)}</button>`;
    }
    return `${pad}<${mapping.tag} className="${mapping.className}" onClick={() => ${actionName}(${actionArgs})} />`;
  }

  // Element with binding
  if (resolved.binding) {
    return generateBoundElement(resolved, mapping, ctx, analysis, scope, ind);
  }

  // Element with label (stat:"Total")
  if (resolved.label !== undefined) {
    if (resolved.element === 'stat') {
      return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-sm opacity-70">${escapeText(resolved.label)}</div>\n${pad}  <div className="text-2xl font-bold">--</div>\n${pad}</div>`;
    }
    return `${pad}<${mapping.tag} className="${mapping.className}">${escapeText(resolved.label)}</${mapping.tag}>`;
  }

  // Element with children from resolved bind
  if (resolved.children && resolved.children.length > 0) {
    const childJsx = resolved.children.map(c =>
      generateJSX(c, ctx, analysis, scope, ind + 2)
    ).filter(Boolean).join('\n');
    return `${pad}<${mapping.tag}${classAttr(mapping.className)}>\n${childJsx}\n${pad}</${mapping.tag}>`;
  }

  // Simple styled element
  if (mapping.selfClosing) {
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    return `${pad}<${mapping.tag}${typeAttr}${classAttr(mapping.className)} />`;
  }

  return `${pad}<${mapping.tag}${classAttr(mapping.className)}></${mapping.tag}>`;
}

// ---- Dot (.) ----

function generateDotJSX(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const expr = resolveDotExpr(node, scope);
  return `${pad}{${expr}}`;
}

// ---- Helpers ----

function generateProgressBar(
  resolved: ResolvedBind,
  ctx: TranspileContext,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  // Extract value and max from children (which are config params like value:#expr, max:#expr)
  let valueExpr = '0';
  let maxExpr = '100';
  for (const child of resolved.children ?? []) {
    if (child.kind === 'binary' && child.operator === '|') {
      // Chained pipe: value:#expenses|sum(amount)
      // Left side is bind(value, #expenses), right side is sum(amount)
      if (child.left.kind === 'binary' && child.left.operator === ':') {
        const bindResolved = resolveBindChain(child.left);
        if (bindResolved && (bindResolved.element === 'value' || bindResolved.modifiers.includes('value'))) {
          const src = bindResolved.binding ? resolveRefNode(bindResolved.binding, scope) : '0';
          valueExpr = resolvePipeExprFromSourceAndRight(src, child.right, ctx, scope);
        }
      }
    } else if (child.kind === 'binary' && child.operator === ':') {
      const bindResolved = resolveBindChain(child);
      if (bindResolved) {
        if (bindResolved.element === 'value' && bindResolved.binding) {
          valueExpr = resolveRefNode(bindResolved.binding, scope);
        } else if (bindResolved.element === 'max' && bindResolved.binding) {
          maxExpr = resolveRefNode(bindResolved.binding, scope);
        }
      }
    }
  }
  return `${pad}<div className="w-full bg-white/10 rounded-full h-3 overflow-hidden">\n`
    + `${pad}  <div className="h-full bg-[var(--accent)] rounded-full transition-all" style={{ width: \`\${Math.min(100, (${valueExpr}) / (${maxExpr}) * 100)}%\` }}></div>\n`
    + `${pad}</div>`;
}

function resolvePipeExprFromSourceAndRight(src: string, right: AirUINode, ctx: TranspileContext, scope: Scope): string {
  if (right.kind === 'element') {
    const fn = right.element;
    const args = right.children?.map(c => c.kind === 'element' ? c.element : nodeToString(c)) ?? [];
    if (fn === 'sum' && args.length > 0) return `${src}.reduce((s, x) => s + x.${args[0]}, 0)`;
    if (fn === 'avg' && args.length > 0) return `(${src}.length ? ${src}.reduce((s, x) => s + x.${args[0]}, 0) / ${src}.length : 0)`;
  }
  return src;
}

function generateBoundElement(
  resolved: ResolvedBind,
  mapping: ReturnType<typeof mapElement>,
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const binding = resolved.binding!;

  // Checkbox bound to boolean
  if (resolved.element === 'check' || mapping.inputType === 'checkbox') {
    const ref = resolveRef(binding.kind === 'unary' ? binding.operand : binding, scope);
    if (scope.insideIter && scope.iterVar) {
      const arrayName = scope.baseArray || 'items';
      // Extract the boolean field name from the ref (e.g., "item.done" → "done")
      const boolField = ref.includes('.') ? ref.split('.').pop() : 'done';
      return `${pad}<input type="checkbox" checked={${ref}} onChange={() => ${setter(arrayName)}(prev => prev.map(_i => _i.id === ${scope.iterVar}.id ? { ..._i, ${boolField}: !_i.${boolField} } : _i))} />`;
    }
    return `${pad}<input type="checkbox" checked={${ref}} onChange={() => ${setter(ref)}(!${ref})} />`;
  }

  // Input bound to state
  if (mapping.tag === 'input' || resolved.element === 'search') {
    const ref = resolveRef(binding.kind === 'unary' ? binding.operand : binding, scope);
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    return `${pad}<input${typeAttr} className="${mapping.className}" value={${ref}} onChange={(e) => ${resolveSetterFromRef(ref)}(e.target.value)} placeholder="${capitalize(resolved.modifiers[0] || resolved.element)}..." />`;
  }

  // Select bound to state
  if (resolved.element === 'select') {
    const ref = resolveRef(binding.kind === 'unary' ? binding.operand : binding, scope);
    const stateField = findStateField(ref, ctx);
    const options = stateField?.type.kind === 'enum' ? stateField.type.values : [];
    const optionsJsx = options.map(o => `${pad}    <option value="${o}">${o}</option>`).join('\n');
    return `${pad}<select className="${mapping.className}" value={${ref}} onChange={(e) => ${resolveSetterFromRef(ref)}(e.target.value)}>\n${optionsJsx}\n${pad}</select>`;
  }

  // Badge showing value
  if (resolved.element === 'badge') {
    const ref = resolveRefNode(binding, scope);
    return `${pad}<span className="${mapping.className}">{${ref}}</span>`;
  }

  // Text/span showing value
  if (resolved.element === 'text' || resolved.element === 'p') {
    const ref = resolveRefNode(binding, scope);
    const hasCurrency = binding.kind === 'unary' && binding.operator === '$';
    if (hasCurrency) {
      const inner = resolveRef(binding.operand, scope);
      return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{'$' + ${inner}}</${mapping.tag}>`;
    }
    return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${ref}}</${mapping.tag}>`;
  }

  // Stat element with label and value
  if (resolved.element === 'stat' && resolved.label !== undefined) {
    const ref = resolveRefNode(binding, scope);
    return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-sm opacity-70">${escapeText(resolved.label)}</div>\n${pad}  <div className="text-2xl font-bold">{${ref}}</div>\n${pad}</div>`;
  }

  // Image with src
  if (resolved.element === 'img') {
    const src = binding.kind === 'text' ? binding.text
      : binding.kind === 'element' ? binding.element
      : nodeToString(binding);
    return `${pad}<img src="${src}" alt="${resolved.modifiers[0] || 'image'}" className="${mapping.className}" />`;
  }

  // Link with href
  if (resolved.element === 'link') {
    const href = binding.kind === 'text' ? binding.text
      : binding.kind === 'element' ? binding.element
      : '#';
    return `${pad}<a href="${href.startsWith('/') ? '#' + href : href}" className="${mapping.className}">`;
  }

  // Generic: render element displaying the binding value
  const ref = resolveRefNode(binding, scope);
  if (mapping.selfClosing) {
    return `${pad}<${mapping.tag}${classAttr(mapping.className)} value={${ref}} />`;
  }
  return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${ref}}</${mapping.tag}>`;
}

function generateElementWithAction(
  element: AirUINode,
  action: AirUINode & { kind: 'unary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const actionName = extractActionName(action.operand);
  const actionArgs = extractActionArgs(action.operand, scope);

  const resolved = tryResolveElement(element);
  if (!resolved) {
    return `${pad}<button onClick={() => ${actionName}(${actionArgs})}>${actionName}</button>`;
  }

  const mapping = mapElement(resolved.element, resolved.modifiers);

  // Form with submission
  if (resolved.element === 'form') {
    const childJsx = resolved.children
      ? resolved.children.map(c => generateJSX(c, ctx, analysis, scope, ind + 2)).filter(Boolean).join('\n')
      : '';
    return `${pad}<form className="${mapping.className}" onSubmit={(e) => { e.preventDefault(); ${actionName}(${actionArgs}); }}>\n${childJsx}\n${pad}</form>`;
  }

  // Button with onClick
  if (mapping.tag === 'button') {
    const label = resolved.children
      ? resolved.children.map(c => {
          if (c.kind === 'text') return escapeText(c.text);
          return '';
        }).join('')
      : actionName;
    return `${pad}<button className="${mapping.className}" onClick={() => ${actionName}(${actionArgs})}>${label || actionName}</button>`;
  }

  // Input with onKeyDown enter handler
  if (mapping.tag === 'input') {
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    return `${pad}<input${typeAttr} className="${mapping.className}" placeholder="Add..." onKeyDown={(e) => { if (e.key === 'Enter' && e.target.value) { ${actionName}(${actionArgs || 'e.target.value'}); e.target.value = ''; } }} />`;
  }

  // Generic element with onClick
  const childJsx = resolved.children
    ? '\n' + resolved.children.map(c => generateJSX(c, ctx, analysis, scope, ind + 2)).filter(Boolean).join('\n') + '\n' + pad
    : '';
  return `${pad}<${mapping.tag}${classAttr(mapping.className)} onClick={() => ${actionName}(${actionArgs})}>${childJsx}</${mapping.tag}>`;
}

function generateIterationJSX(
  node: AirUINode & { kind: 'unary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Extract iteration variable name and children
  let iterVar = 'item';
  let children: AirUINode[] = [];
  if (node.operand.kind === 'element') {
    iterVar = node.operand.element;
    children = node.operand.children ?? [];
  }

  // Data source: look at parent context (passed from flow handler)
  const dataExpr = scope.iterData || 'items';
  const newScope: Scope = { iterVar, iterData: dataExpr, insideIter: true };

  const childJsx = children.map(c =>
    generateJSX(c, ctx, analysis, newScope, ind + 4)
  ).filter(Boolean).join('\n');

  return `${pad}{${dataExpr}.map((${iterVar}) => (\n${pad}  <div key={${iterVar}.id} className="flex gap-4 items-center">\n${childJsx}\n${pad}  </div>\n${pad}))}`;
}

function generateContainerWithIteration(
  leftNode: AirUINode,
  dataSource: string,
  iterNode: AirUINode & { kind: 'unary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Extract the container element from the left side
  let containerElement = 'div';
  let containerClass = '';

  if (leftNode.kind === 'binary' && leftNode.operator === '>') {
    // Chain: container > dataExpr
    const containerResolved = tryResolveElement(leftNode.left);
    if (containerResolved) {
      const mapping = mapElement(containerResolved.element, containerResolved.modifiers);
      containerElement = mapping.tag;
      containerClass = mapping.className;
    }
  } else {
    const containerResolved = tryResolveElement(leftNode);
    if (containerResolved) {
      const mapping = mapElement(containerResolved.element, containerResolved.modifiers);
      containerElement = mapping.tag;
      containerClass = mapping.className;
    }
  }

  // Generate iteration inside the container
  let iterVar = 'item';
  let children: AirUINode[] = [];
  if (iterNode.operand.kind === 'element') {
    iterVar = iterNode.operand.element;
    children = iterNode.operand.children ?? [];
  }

  // Extract base array name for mutations (e.g., "items" from "items.filter(...)")
  const baseArray = extractBaseArrayName(leftNode);
  const newScope: Scope = { iterVar, iterData: dataSource, baseArray, insideIter: true };

  const childJsx = children.map(c =>
    generateJSX(c, ctx, analysis, newScope, ind + 4)
  ).filter(Boolean).join('\n');

  return `${pad}<${containerElement}${classAttr(containerClass)}>\n`
    + `${pad}  {${dataSource}.map((${iterVar}) => (\n`
    + `${pad}    <div key={${iterVar}.id} className="flex gap-2 items-center">\n`
    + `${childJsx}\n`
    + `${pad}    </div>\n`
    + `${pad}  ))}\n`
    + `${pad}</${containerElement}>`;
}

function generateFlowBoundElement(
  resolved: { element: string; modifiers: string[]; children?: AirUINode[] },
  stateRef: string,
  ctx: TranspileContext,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const mapping = mapElement(resolved.element, resolved.modifiers);
  const setterExpr = resolveSetterFromRef(stateRef);

  // Input: value + onChange
  if (mapping.tag === 'input' || resolved.element === 'search') {
    const typeAttr = mapping.inputType ? ` type="${mapping.inputType}"` : '';
    const placeholder = resolved.modifiers[0] || resolved.element;
    return `${pad}<input${typeAttr} className="${mapping.className}" value={${stateRef}} onChange={(e) => ${setterExpr}(e.target.value)} placeholder="${capitalize(placeholder)}..." />`;
  }

  // Select: value + onChange with enum options
  if (resolved.element === 'select') {
    const enumValues = findEnumValues(stateRef, resolved.modifiers, ctx);
    const optionsJsx = enumValues.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n');
    return `${pad}<select className="${mapping.className}" value={${stateRef}} onChange={(e) => ${setterExpr}(e.target.value)}>\n${optionsJsx}\n${pad}</select>`;
  }

  // Tabs: generate button group from enum values
  if (resolved.element === 'tabs') {
    const enumValues = findEnumValues(stateRef, resolved.modifiers, ctx);
    if (enumValues.length > 0) {
      const optionsStr = enumValues.map(o => JSON.stringify(o)).join(', ');
      return `${pad}<div className="flex gap-2">\n`
        + `${pad}  {[${optionsStr}].map((_tab) => (\n`
        + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-lg cursor-pointer transition-colors \${${stateRef} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent hover:bg-white/10'}\`} onClick={() => ${setterExpr}(_tab)}>{_tab}</button>\n`
        + `${pad}  ))}\n`
        + `${pad}</div>`;
    }
  }

  // Stat: display value
  if (resolved.element === 'stat') {
    const bindResolved = resolveBindChain({ kind: 'binary', operator: ':', left: { kind: 'element', element: resolved.element }, right: { kind: 'text', text: '' } } as any);
    return `${pad}<div className="${mapping.className}">\n${pad}  <div className="text-2xl font-bold">{${stateRef}}</div>\n${pad}</div>`;
  }

  // Generic: display value
  if (mapping.selfClosing) {
    return `${pad}<${mapping.tag}${classAttr(mapping.className)} value={${stateRef}} />`;
  }
  return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${stateRef}}</${mapping.tag}>`;
}

function findEnumValues(stateRef: string, modifiers: string[], ctx: TranspileContext): string[] {
  // Direct state field lookup
  const field = findStateField(stateRef, ctx);
  if (field) {
    const deepType = resolveDeepType(field.type, stateRef);
    if (deepType?.kind === 'enum' && deepType.values.length > 0) return deepType.values;
  }
  // Look for enum by modifier name (e.g., select:category → find category enum in any state field)
  for (const mod of modifiers) {
    for (const f of ctx.state) {
      const enumType = findEnumByName(f.type, mod);
      if (enumType) return enumType.values;
    }
  }
  return [];
}

function resolveDeepType(type: AirType, path: string): AirType | null {
  const parts = path.split('.');
  if (parts.length <= 1) return type;
  // Walk into object types
  let current = type;
  for (let i = 1; i < parts.length; i++) {
    if (current.kind === 'object') {
      const field = current.fields.find(f => f.name === parts[i]);
      if (field) { current = field.type; } else { return null; }
    } else if (current.kind === 'optional') {
      current = current.of;
      i--; // retry with inner type
    } else {
      return null;
    }
  }
  return current;
}

function findEnumByName(type: AirType, name: string): AirType & { kind: 'enum' } | null {
  if (type.kind === 'enum') return type;
  if (type.kind === 'array' && type.of.kind === 'object') {
    for (const f of type.of.fields) {
      if (f.name === name && f.type.kind === 'enum') return f.type;
    }
  }
  if (type.kind === 'object') {
    for (const f of type.fields) {
      if (f.name === name && f.type.kind === 'enum') return f.type;
    }
  }
  return null;
}

function generateSetterElement(
  leftNode: AirUINode,
  rightNode: AirUINode & { kind: 'element' },
  ctx: TranspileContext,
  _analysis: UIAnalysis,
  _scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);
  const stateVar = rightNode.element.replace('.set', '');
  const options = rightNode.children?.map(c =>
    c.kind === 'element' ? c.element : nodeToString(c)
  ) ?? [];

  const leftResolved = tryResolveElement(leftNode);

  if (leftResolved?.element === 'tabs' || leftResolved?.element === 'row') {
    // Tabs: render buttons for each option
    const optionsStr = options.map(o => JSON.stringify(o)).join(', ');
    return `${pad}<div className="flex gap-2">\n`
      + `${pad}  {[${optionsStr}].map((_tab) => (\n`
      + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-lg cursor-pointer transition-colors \${${stateVar} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent hover:bg-white/10'}\`} onClick={() => set${capitalize(stateVar)}(_tab)}>{_tab}</button>\n`
      + `${pad}  ))}\n`
      + `${pad}</div>`;
  }

  if (leftResolved?.element === 'select') {
    return `${pad}<select className="border border-white/20 rounded-lg px-3 py-2 bg-transparent" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
      + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
      + `${pad}</select>`;
  }

  // Generic: render as tab buttons
  const optionsStr = options.map(o => JSON.stringify(o)).join(', ');
  return `${pad}<div className="flex gap-2">\n`
    + `${pad}  {[${optionsStr}].map((_tab) => (\n`
    + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-lg cursor-pointer transition-colors \${${stateVar} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent hover:bg-white/10'}\`} onClick={() => set${capitalize(stateVar)}(_tab)}>{_tab}</button>\n`
    + `${pad}  ))}\n`
    + `${pad}</div>`;
}

function generateFlowWithDot(
  left: AirUINode,
  dot: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Pattern: tabs > filter.set(options) → tab buttons
  const leftResolved = tryResolveElement(left);
  if (dot.left.kind === 'element' && dot.right.kind === 'element' && dot.right.element === 'set') {
    const stateVar = dot.left.element;
    const options = dot.right.children?.map(c => c.kind === 'element' ? c.element : nodeToString(c)) ?? [];

    if (leftResolved?.element === 'tabs') {
      const optionsStr = options.map(o => JSON.stringify(o)).join(', ');
      return `${pad}<div className="flex gap-2">\n`
        + `${pad}  {[${optionsStr}].map((_tab) => (\n`
        + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-lg cursor-pointer transition-colors \${${stateVar} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent hover:bg-white/10'}\`} onClick={() => set${capitalize(stateVar)}(_tab)}>{_tab}</button>\n`
        + `${pad}  ))}\n`
        + `${pad}</div>`;
    }

    // select > stateVar.set → select with options
    if (leftResolved?.element === 'select') {
      const mapping = mapElement('select', []);
      return `${pad}<select className="${mapping.className}" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
        + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
        + `${pad}</select>`;
    }
  }

  // Pattern: stateName.select → selector for enum state
  if (dot.right.kind === 'element' && dot.right.element === 'select') {
    const stateVar = dot.left.kind === 'element' ? dot.left.element : '';
    if (stateVar) {
      const stateField = findStateField(stateVar, ctx);
      const options = stateField?.type.kind === 'enum' ? stateField.type.values : [];
      return `${pad}<select className="border border-white/20 rounded-lg px-3 py-2 bg-transparent" value={${stateVar}} onChange={(e) => set${capitalize(stateVar)}(e.target.value)}>\n`
        + options.map(o => `${pad}  <option value="${o}">${o}</option>`).join('\n') + '\n'
        + `${pad}</select>`;
    }
  }

  // Generic: render left with dot expression as child
  if (leftResolved) {
    const mapping = mapElement(leftResolved.element, leftResolved.modifiers);
    const expr = resolveDotExpr(dot, scope);
    return `${pad}<${mapping.tag}${classAttr(mapping.className)}>{${expr}}</${mapping.tag}>`;
  }

  return `${pad}{${resolveDotExpr(dot, scope)}}`;
}

function generateFlowChain(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // Flatten the > chain
  const parts: AirUINode[] = [];
  let current: AirUINode = node;
  while (current.kind === 'binary' && current.operator === '>') {
    parts.push(current.right);
    current = current.left;
  }
  parts.push(current);
  parts.reverse();

  // parts[0] is the container, rest are content/data/iteration

  // Find container
  const containerResolved = tryResolveElement(parts[0]);

  // Find data source (pipe expressions)
  let dataExpr: string | null = null;
  for (let i = 1; i < parts.length; i++) {
    const part = parts[i];
    if (part.kind === 'binary' && part.operator === '|') {
      dataExpr = resolvePipeExpr(part, ctx, scope);
    } else if (part.kind === 'element') {
      // Could be a data reference (like 'items')
      const stateField = findStateField(part.element, ctx);
      if (stateField && stateField.type.kind === 'array') {
        dataExpr = stateField.name;
      }
    }
  }

  // Find iteration
  const iterPart = parts.find(p => p.kind === 'unary' && (p as AirUINode & { kind: 'unary' }).operator === '*');
  if (iterPart && iterPart.kind === 'unary') {
    // Extract base array name for mutations from data parts
    let baseArray = 'items';
    for (const p of parts) {
      if (p.kind === 'element') {
        const sf = findStateField(p.element, ctx);
        if (sf && sf.type.kind === 'array') { baseArray = sf.name; break; }
      }
    }
    const iterScope: Scope = { ...scope, iterData: dataExpr || baseArray, baseArray, insideIter: true };
    if (iterPart.operand.kind === 'element') {
      iterScope.iterVar = iterPart.operand.element;
    }

    const containerMapping = containerResolved ? mapElement(containerResolved.element, containerResolved.modifiers) : { tag: 'div', className: '' };

    let iterVar = iterScope.iterVar || 'item';
    let children = iterPart.operand.kind === 'element' ? (iterPart.operand.children ?? []) : [];

    const childJsx = children.map(c =>
      generateJSX(c, ctx, analysis, iterScope, ind + 4)
    ).filter(Boolean).join('\n');

    return `${pad}<${containerMapping.tag}${classAttr(containerMapping.className)}>\n`
      + `${pad}  {${dataExpr || 'items'}.map((${iterVar}) => (\n`
      + `${pad}    <div key={${iterVar}.id} className="flex gap-2 items-center">\n`
      + `${childJsx}\n`
      + `${pad}    </div>\n`
      + `${pad}  ))}\n`
      + `${pad}</${containerMapping.tag}>`;
  }

  // No iteration — just nested content
  const contentParts = parts.slice(1);
  const containerMapping = containerResolved ? mapElement(containerResolved.element, containerResolved.modifiers) : { tag: 'div', className: '' };
  const innerJsx = contentParts.map(c =>
    generateJSX(c, ctx, analysis, scope, ind + 2)
  ).filter(Boolean).join('\n');

  return `${pad}<${containerMapping.tag}${classAttr(containerMapping.className)}>\n${innerJsx}\n${pad}</${containerMapping.tag}>`;
}

function generateTabsElement(
  node: AirUINode & { kind: 'element' },
  ctx: TranspileContext,
  analysis: UIAnalysis,
  scope: Scope,
  ind: number,
): string {
  const pad = ' '.repeat(ind);

  // tabs with children that are just option elements
  if (node.children && node.children.length > 0) {
    const options = node.children.map(c => {
      if (c.kind === 'element') return c.element;
      return nodeToString(c);
    });

    // Try to find a filter state
    const filterField = ctx.state.find(f => f.type.kind === 'enum');
    if (filterField) {
      const optionsStr = options.map(o => JSON.stringify(o)).join(', ');
      return `${pad}<div className="flex gap-2">\n`
        + `${pad}  {[${optionsStr}].map((_tab) => (\n`
        + `${pad}    <button key={_tab} className={\`px-4 py-2 rounded-lg cursor-pointer transition-colors \${${filterField.name} === _tab ? 'bg-[var(--accent)] text-white' : 'bg-transparent hover:bg-white/10'}\`} onClick={() => set${capitalize(filterField.name)}(_tab)}>{_tab}</button>\n`
        + `${pad}  ))}\n`
        + `${pad}</div>`;
    }
  }

  return `${pad}<div className="flex gap-2">{/* tabs */}</div>`;
}

// ---- Expression Resolvers ----

function resolveRef(node: AirUINode, scope: Scope): string {
  if (node.kind === 'element') {
    // Sanitize element name — strip trailing operators that shouldn't be in JS expressions
    const name = node.element.replace(/[-+*/]+$/, '');
    if (scope.insideIter && scope.iterVar && name === scope.iterVar) {
      return scope.iterVar;
    }
    return name;
  }
  if (node.kind === 'binary' && node.operator === '.') {
    const left = resolveRef(node.left, scope);
    const right = resolveRef(node.right, scope);
    return `${left}.${right}`;
  }
  if (node.kind === 'unary' && node.operator === '#') {
    return resolveRef(node.operand, scope);
  }
  if (node.kind === 'text') {
    return JSON.stringify(node.text);
  }
  if (node.kind === 'value') {
    return JSON.stringify(node.value);
  }
  return nodeToString(node);
}

function resolveRefNode(node: AirUINode, scope: Scope): string {
  if (node.kind === 'unary' && node.operator === '#') {
    return resolveRef(node.operand, scope);
  }
  if (node.kind === 'unary' && node.operator === '$') {
    const inner = resolveRefNode(node.operand, scope);
    return `'$' + ${inner}`;
  }
  if (node.kind === 'binary' && node.operator === '.') {
    return resolveDotExpr(node, scope);
  }
  if (node.kind === 'binary' && node.operator === '|') {
    return resolvePipeExprSimple(node, scope);
  }
  if (node.kind === 'binary' && node.operator === '-') {
    return `${resolveRefNode(node.left, scope)} - ${resolveRefNode(node.right, scope)}`;
  }
  return resolveRef(node, scope);
}

function resolveDotExpr(node: AirUINode & { kind: 'binary' }, scope: Scope): string {
  const left = resolveRef(node.left, scope);
  const right = node.right.kind === 'element' ? node.right.element : resolveRef(node.right, scope);
  return `${left}.${right}`;
}

function resolvePipeExpr(
  node: AirUINode & { kind: 'binary' },
  ctx: TranspileContext,
  scope: Scope,
): string {
  const left = resolvePipeSource(node.left, ctx, scope);
  const right = node.right;

  if (right.kind === 'element') {
    const fn = right.element;
    const args = right.children?.map(c => c.kind === 'element' ? c.element : nodeToString(c)) ?? [];

    switch (fn) {
      case 'filter': {
        // Check if there's an enum filter state
        const filterField = ctx.state.find(f => f.name === 'filter' && f.type.kind === 'enum');
        if (filterField) {
          return `${left}.filter(_item => filter === 'all' || _item.category === filter || _item.done === (filter === 'done'))`;
        }
        return `${left}`;
      }
      case 'sort': {
        const sortField = ctx.state.find(f => f.name === 'sort');
        if (sortField) {
          return `[...${left}].sort((a, b) => sort === 'newest' ? b.id - a.id : sort === 'oldest' ? a.id - b.id : sort === 'highest' ? b.amount - a.amount : a.amount - b.amount)`;
        }
        return left;
      }
      case 'sum':
        if (args.length > 0) {
          return `${left}.reduce((s, x) => s + x.${args[0]}, 0)`;
        }
        return `${left}.reduce((s, x) => s + x, 0)`;
      case 'avg':
        if (args.length > 0) {
          return `(${left}.length ? ${left}.reduce((s, x) => s + x.${args[0]}, 0) / ${left}.length : 0)`;
        }
        return `(${left}.length ? ${left}.reduce((s, x) => s + x, 0) / ${left}.length : 0)`;
      case 'count':
        return `${left}.length`;
      case 'search': {
        return `${left}.filter(_item => Object.values(_item).some(v => String(v).toLowerCase().includes(search.toLowerCase())))`;
      }
      default:
        return `${left} /* |${fn} */`;
    }
  }

  // Chained pipes: left | right where right is also a pipe
  if (right.kind === 'binary' && right.operator === '|') {
    return resolvePipeExpr(
      { ...right, left: { kind: 'text', text: resolvePipeExpr({ kind: 'binary', operator: '|', left: node.left, right: right.left }, ctx, scope) } } as AirUINode & { kind: 'binary' },
      ctx,
      scope,
    );
  }

  return left;
}

function resolvePipeExprSimple(node: AirUINode & { kind: 'binary' }, scope: Scope): string {
  const left = resolveRefNode(node.left, scope);
  const right = node.right;

  if (right.kind === 'element') {
    const fn = right.element;
    const args = right.children?.map(c => c.kind === 'element' ? c.element : nodeToString(c)) ?? [];

    switch (fn) {
      case 'sum':
        return args.length > 0
          ? `${left}.reduce((s, x) => s + x.${args[0]}, 0)`
          : `${left}.reduce((s, x) => s + x, 0)`;
      case 'avg':
        return args.length > 0
          ? `(${left}.length ? ${left}.reduce((s, x) => s + x.${args[0]}, 0) / ${left}.length : 0)`
          : `(${left}.length ? ${left}.reduce((s, x) => s + x, 0) / ${left}.length : 0)`;
      default:
        return `${left}.${fn}`;
    }
  }

  return left;
}

function resolvePipeSource(node: AirUINode, ctx: TranspileContext, scope: Scope): string {
  if (node.kind === 'element') return node.element;
  if (node.kind === 'unary' && node.operator === '#') return resolveRef(node.operand, scope);
  if (node.kind === 'unary' && node.operator === '$') return resolvePipeSource(node.operand, ctx, scope);
  if (node.kind === 'binary' && node.operator === '.') return resolveDotExpr(node as AirUINode & { kind: 'binary' }, scope);
  if (node.kind === 'binary' && node.operator === '|') return resolvePipeExpr(node as AirUINode & { kind: 'binary' }, ctx, scope);
  if (node.kind === 'binary' && node.operator === ':') {
    // Bind chain — extract the binding value
    const resolved = resolveBindChain(node);
    if (resolved?.binding) return resolvePipeSource(resolved.binding, ctx, scope);
  }
  return nodeToString(node);
}

function extractDataSource(node: AirUINode, scope: Scope): string {
  // From a flow chain, extract the data expression
  if (node.kind === 'binary' && node.operator === '>') {
    // e.g., list > items|filter → data is from the right side
    return extractDataSource(node.right, scope);
  }
  if (node.kind === 'binary' && node.operator === '|') {
    // Pipe chain — recursively resolve left side for chained pipes
    const left = extractDataSource(node.left, scope);
    const right = node.right;
    if (right.kind === 'element') {
      const fn = right.element;
      if (fn === 'filter') {
        return `${left}.filter(_item => filter === 'all' || _item.category === filter || _item.done === (filter === 'done'))`;
      }
      if (fn === 'sort') {
        return `[...${left}].sort((a, b) => sort === 'newest' ? b.id - a.id : sort === 'oldest' ? a.id - b.id : sort === 'highest' ? b.amount - a.amount : a.amount - b.amount)`;
      }
      return `${left}`;
    }
    return left;
  }
  if (node.kind === 'element') {
    return node.element;
  }
  return 'items';
}

function extractActionName(node: AirUINode): string {
  if (node.kind === 'element') return node.element;
  if (node.kind === 'binary' && node.operator === '.') {
    const l = node.left.kind === 'element' ? node.left.element : '';
    const r = node.right.kind === 'element' ? node.right.element : '';
    return `${l}_${r}`;
  }
  return 'action';
}

function extractActionArgs(node: AirUINode, scope: Scope): string {
  if (node.kind === 'element' && node.children && node.children.length > 0) {
    return node.children.map(c => {
      if (c.kind === 'text') {
        // Raw text like {text:#val,done:false} — parse minimally
        let raw = c.text;
        // Parser may produce double braces — normalize to single pair
        if (raw.startsWith('{{') && !raw.startsWith('{{{')) {
          raw = raw.slice(1);
        }
        if (raw.startsWith('{')) {
          // Ensure closing brace
          if (!raw.endsWith('}')) raw = raw + '}';
          // Convert #val references
          return raw.replace(/#(\w+(?:\.\w+)*)/g, (_, name) => {
            if (name === 'val') return 'e.target.value';
            return scope.insideIter && scope.iterVar && name.startsWith(scope.iterVar + '.')
              ? name
              : name;
          });
        }
        // Raw text for array literals like [name,email,...]
        if (raw.startsWith('[')) {
          return raw;
        }
        return JSON.stringify(raw);
      }
      if (c.kind === 'unary' && c.operator === '#') {
        return resolveRef(c.operand, scope);
      }
      if (c.kind === 'binary' && c.operator === '.') {
        return resolveDotExpr(c as AirUINode & { kind: 'binary' }, scope);
      }
      return resolveRefNode(c, scope);
    }).join(', ');
  }
  return '';
}

interface ResolvedElement {
  element: string;
  modifiers: string[];
  children?: AirUINode[];
}

function tryResolveElement(node: AirUINode): ResolvedElement | null {
  if (node.kind === 'element') {
    return { element: node.element, modifiers: [], children: node.children };
  }
  if (node.kind === 'binary' && node.operator === ':') {
    const resolved = resolveBindChain(node);
    if (resolved) {
      return { element: resolved.element, modifiers: resolved.modifiers, children: resolved.children };
    }
  }
  return null;
}

// ---- Text Interpolation ----

function interpolateText(text: string, ctx: TranspileContext, scope: Scope): string {
  // Handle # references inside text strings
  if (text.includes('#')) {
    // Replace #var.prop and #var patterns with ${} expressions
    let result = text.replace(/#(\w+(?:\.\w+)*(?:\|[!]?\w+(?:\.\w+)*)*)/g, (_, ref) => {
      // Handle pipes in text refs like #items|!done.length
      const parts = ref.split('|');
      let expr = parts[0];
      for (let i = 1; i < parts.length; i++) {
        const pipe = parts[i];
        if (pipe.startsWith('!')) {
          // Filter negation: !done → .filter(i => !i.done)
          const field = pipe.slice(1).split('.')[0];
          const rest = pipe.slice(1).split('.').slice(1).join('.');
          expr = `${expr}.filter(i => !i.${field})`;
          if (rest) expr = `${expr}.${rest}`;
        } else {
          expr = `${expr}.${pipe}`;
        }
      }
      return `\${${expr}}`;
    });
    return '`' + result + '`';
  }
  return JSON.stringify(text);
}

function escapeText(text: string): string {
  return text.replace(/[{}<>]/g, c => {
    switch (c) {
      case '{': return '&#123;';
      case '}': return '&#125;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      default: return c;
    }
  });
}

// ---- Utility ----

function classAttr(className: string): string {
  return className ? ` className="${className}"` : '';
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function setter(name: string): string {
  return 'set' + capitalize(name);
}

function resolveSetterFromRef(ref: string): string {
  // ref could be 'input.title' → need setInput(prev => ({...prev, title: value}))
  const parts = ref.split('.');
  if (parts.length === 1) {
    return `set${capitalize(parts[0])}`;
  }
  // For nested: return a lambda
  // Actually return a string that the caller will use differently
  return `((v) => set${capitalize(parts[0])}(prev => ({ ...prev, ${parts.slice(1).join('.')}: v })))`;
}

function findStateField(name: string, ctx: TranspileContext): AirField | undefined {
  // Handle dotted names
  const baseName = name.split('.')[0];
  return ctx.state.find(f => f.name === baseName);
}

function nodeToString(node: AirUINode): string {
  switch (node.kind) {
    case 'text': return node.text;
    case 'value': return String(node.value);
    case 'element': return node.element;
    case 'unary': return `${node.operator}${nodeToString(node.operand)}`;
    case 'binary': return `${nodeToString(node.left)}${node.operator}${nodeToString(node.right)}`;
    case 'scoped': return `@${node.scope}:${node.name}`;
  }
}

function getButtonLabel(resolved: ResolvedBind): string {
  if (resolved.label) return escapeText(resolved.label);
  if (resolved.modifiers.includes('icon')) return '\u2715';
  // Check if action is a delete/remove → use ✕
  if (resolved.action) {
    const actionName = resolved.action.kind === 'unary'
      ? extractActionName(resolved.action.operand)
      : extractActionName(resolved.action);
    if (actionName === 'del' || actionName === 'delete' || actionName === 'remove') return '\u2715';
    return actionName;
  }
  if (resolved.element === 'btn') return 'Submit';
  return resolved.element;
}

function extractBaseArrayName(node: AirUINode): string {
  if (node.kind === 'binary' && node.operator === '>') {
    return extractBaseArrayName(node.right);
  }
  if (node.kind === 'binary' && node.operator === '|') {
    return extractBaseArrayName(node.left);
  }
  if (node.kind === 'element') {
    return node.element;
  }
  return 'items';
}

function indent(lines: string[], n: number): string[] {
  const pad = ' '.repeat(n);
  return lines.flatMap(l => {
    if (!l) return [l];
    if (l.includes('\n')) {
      return l.split('\n').map(sub => sub ? pad + sub : sub);
    }
    return [pad + l];
  });
}
