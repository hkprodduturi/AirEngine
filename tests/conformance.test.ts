/**
 * Conformance Test Suite (6C)
 *
 * Same AIR fixture validated across parser → React target → Express target → Prisma target.
 * Ensures targets don't drift from parser expectations.
 */

import { describe, it, expect } from 'vitest';
import { readFileSync } from 'fs';
import { parse } from '../src/parser/index.js';
import { validate } from '../src/validator/index.js';
import { transpile } from '../src/transpiler/index.js';
import { extractContext } from '../src/transpiler/context.js';
import { generatePrismaSchema } from '../src/transpiler/prisma.js';
import type { AirDbBlock } from '../src/parser/types.js';

// Use fullstack-todo as the cross-target conformance fixture
const FIXTURE = readFileSync('examples/fullstack-todo.air', 'utf-8');

describe('Cross-target conformance: fullstack-todo', () => {
  const ast = parse(FIXTURE);
  const ctx = extractContext(ast);

  // ---- Stage 1: Parse succeeds ----
  it('parse succeeds without errors', () => {
    expect(ast.app.name).toBe('fullstack-todo');
    expect(ast.app.blocks.length).toBeGreaterThan(0);
  });

  it('validation passes', () => {
    const v = validate(ast);
    expect(v.valid).toBe(true);
  });

  // ---- Stage 2: Context extraction correct ----
  it('context extracts backend flag', () => {
    expect(ctx.hasBackend).toBe(true);
  });

  it('context has db models', () => {
    expect(ctx.db).toBeDefined();
    expect(ctx.db!.models.length).toBeGreaterThan(0);
  });

  it('context has api routes', () => {
    expect(ctx.apiRoutes.length).toBeGreaterThan(0);
  });

  it('context has expanded routes', () => {
    expect(ctx.expandedRoutes.length).toBeGreaterThan(0);
  });

  // ---- Stage 3: Client files present ----
  it('transpile produces client files', () => {
    const result = transpile(ast);
    expect(result.files.some(f => f.path.startsWith('client/'))).toBe(true);
    expect(result.files.some(f => f.path.includes('App.jsx'))).toBe(true);
    expect(result.files.some(f => f.path.includes('main.jsx'))).toBe(true);
  });

  it('client has scaffold files', () => {
    const result = transpile(ast);
    expect(result.files.some(f => f.path.includes('package.json'))).toBe(true);
    expect(result.files.some(f => f.path.includes('vite.config'))).toBe(true);
    expect(result.files.some(f => f.path.includes('index.html'))).toBe(true);
  });

  it('client has API client', () => {
    const result = transpile(ast);
    expect(result.files.some(f => f.path.includes('api.js'))).toBe(true);
  });

  // ---- Stage 4: Server files present ----
  it('transpile produces server files', () => {
    const result = transpile(ast);
    expect(result.files.some(f => f.path.startsWith('server/'))).toBe(true);
    expect(result.files.some(f => f.path.includes('server.ts'))).toBe(true);
  });

  it('server has Prisma schema', () => {
    const result = transpile(ast);
    expect(result.files.some(f => f.path.includes('schema.prisma'))).toBe(true);
  });

  it('server has seed file', () => {
    const result = transpile(ast);
    expect(result.files.some(f => f.path.includes('seed.ts'))).toBe(true);
  });

  // ---- Stage 5: Prisma schema valid ----
  it('Prisma schema has correct models', () => {
    const db = ast.app.blocks.find(b => b.kind === 'db') as AirDbBlock;
    const schema = generatePrismaSchema(db);
    expect(schema).toContain('model Todo');
    expect(schema).toContain('@id');
    expect(schema).toContain('generator client');
    expect(schema).toContain('datasource db');
  });

  // ---- Stage 6: Stats consistency ----
  it('stats are consistent', () => {
    const result = transpile(ast);
    expect(result.stats.modules).toBe(result.files.length);
    expect(result.stats.outputLines).toBeGreaterThan(0);
    expect(result.stats.deadLines).toBeLessThan(result.stats.outputLines);
    expect(result.stats.timing.totalMs).toBeGreaterThan(0);
  });
});

// Multi-example conformance: every example parse+transpile roundtrip
describe('All examples conformance', () => {
  const examples = ['todo', 'expense-tracker', 'auth', 'dashboard', 'landing', 'fullstack-todo', 'projectflow'];

  for (const name of examples) {
    describe(`${name}.air`, () => {
      const source = readFileSync(`examples/${name}.air`, 'utf-8');
      const ast = parse(source);
      const result = transpile(ast);

      it('parse → transpile roundtrip succeeds', () => {
        expect(result.files.length).toBeGreaterThan(0);
      });

      it('has manifest file', () => {
        expect(result.files.some(f => f.path === '_airengine_manifest.json')).toBe(true);
      });

      it('all source files have provenance header', () => {
        for (const f of result.files) {
          if (/\.(jsx|tsx|ts|js)$/.test(f.path)) {
            expect(f.content.startsWith('// Generated by AirEngine'), `${f.path} missing provenance`).toBe(true);
          }
        }
      });

      it('stats are non-negative', () => {
        expect(result.stats.outputLines).toBeGreaterThan(0);
        expect(result.stats.modules).toBeGreaterThan(0);
        expect(result.stats.deadLines).toBeGreaterThanOrEqual(0);
        expect(result.stats.timing.totalMs).toBeGreaterThanOrEqual(0);
      });
    });
  }
});
